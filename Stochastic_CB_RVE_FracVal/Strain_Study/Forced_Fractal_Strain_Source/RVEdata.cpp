#define _USE_MATH_DEFINES

//#define WINDOWS

#ifdef WINDOWS
#include <direct.h>
#define getcwd _getcwd
#else
#include <unistd.h>
#define getcwd getcwd
#endif

#include <iostream>
#include <fstream>
#include <future>
#include <mutex>
#include <deque>
#include <sstream>
#include <string>
#include <vector>
#include <math.h>
#include <random>
#include <algorithm>
#include "Files.h"
#include "PolymerData.h"
#include "CBparticle.h"
#include "CBMaterialData.h"
#include <Eigen/Core>
//#include <Eigen/SparseLU>
#include <Eigen/SparseCholesky>
#define BOOST_NO_CXX11_SCOPED_ENUMS
#define BOOST_FILESYSTEM_NO_DEPRECATED
#include <boost/filesystem.hpp>
#define BOOST_NO_CXX11_SCOPED_ENUMS
#include "RVEdata.h"

RVEdata::RVEdata(){};

RVEdata::~RVEdata(){};

//Check vectors to see if they hold a similar integer
bool RVEdata::CheckInVector(std::vector<long int> &ParticleN, long int ParticleIndexO)
{
    if (std::find(ParticleN.begin(), ParticleN.end(), ParticleIndexO) != ParticleN.end())
    {
        return (true);
    }
    else
    {
        return (false);
    }
}

//Function to read pertinent simulation variables from the input file (Input_Parameters.txt).
//Function arguments are global variables containing command line inputs that are stored/used
//by other objects defined/initialized in this function.
void RVEdata::ReadInputData(std::ifstream &fin, std::ofstream &ferr, int cmd_PctRandLower, int cmd_PctRandUpper, int cmd_XY, int cmd_thickness, int cmd_wcb, int cmd_fill)
{
    //Define strings/variables for parsing the input file
    double NotNeeded;
    std::string lines, ignore;
    
    //Read in first row of problem parameters from the Input_Parameters.txt file
    fin >> Xbound >> Ybound >> Zbound >> NumCBFillers >> NumCNTFillers >> Pct_Rand >> d;
    
    //Define the multiplier for converting unit steps to actual distance (i.e. if 1 unit step = 3 nm, mult = 3)
    mult = round(d/pow(10,-9));
    
    //Random number generator seeds are created by concatenating the random process id number
    //(generated by the CPU) with the time(NULL) function. This gives each simulation a unique seed.
    //First convert both the integers to string
    std::string s1 = std::to_string(time(NULL));
    std::string s2 = std::to_string(getpid());
    
    //Then concatenate both strings
    std::string s = s1 + s2;
    
    //Convert the concatenated string to integer
    long int c = std::stol(s);
    
    //Initialize the random seed
    srand(c);
    
    //Initialize the mersenne twister random number generator using the seed
    std::mt19937_64 gen(rand());
    
    //The code was  written to allow for a range "Random Seed Percentage" values to be selected from.
    //In most cases, the range of values are limited to ONE possible value (cmd_PctRandLower = cmd_PctRandUpper)
    //Initialize the uniform integer distribution of Random Percentage list to randomly choose from
    std::uniform_int_distribution<int> Qdist(cmd_PctRandLower, cmd_PctRandUpper);
    
    //Pick a random integer from Qdist, and convert to a percentage (divided by 10 million)
    //This scale was found by guess and check trying to force realistic agglomeration. The 10 million number
    //was arbitrarily found. Typical values for cmd_PctRandLower are around 1000-100000. In the 2022 papers,
    //the value for cmd_PctRandLower was set at 28000.
    Pct_Rand = Qdist(gen)/10000000.;

    //Define RVEdata object parameters used by object functions
    //Percent Fill is input as an integer command line variable. It is converted to a fraction here.
    Pct_Fill = cmd_fill/100.;
    Zbound = cmd_thickness;
    Xbound = cmd_XY;
    Ybound = cmd_XY;
    Wcb = cmd_wcb/100.;
    
    //Resize vector to create CB filler material(s) object(s). At this point, only single
    //CB systems have been tested. Additional coding needed to test multi-CB type systems.
    CB_data.resize(NumCBFillers);

    //Define temporary containers for reading/converting input data from Input_Parameters.txt file
    int ID, diamUpper, diamLower, ps;
    double rho;
    
    //MaxParitlceDiameter variable used to determine how big the index map needs to be.
    //The map needs to at least accomodate the biggest particles. Up to this point, only monodisperse
    //CB elements have been deployed (only one size of particle). Additioanl coding needed for polydispersity.
    MaxParticleDiameter = 0;
    
    //This is used to bypass the Input_Parameters.txt weight pct variable
    float Real_Wcb = cmd_wcb/100.;

    //Loop to parse the input file data for filler(s)
    for (int i = 0; i < NumCBFillers; i++)
    {
        fin >> ID >> Wcb >> rho >> diamLower >> diamUpper >> ps;
        Wcb = Real_Wcb;
        
        //Initialize the CBdata object for each type of CB filler defined in the input parameters text file
        CB_data[i].initialize(ID, rho, diamLower, diamUpper, ps, d);
        
        //Push back vector containing the mass fractions of each filler type in the CPC
        MassFractionOfFillers.push_back(Wcb);
        
        //Check if CB filler i has a larger max radius than i-1
        if (diamUpper > MaxParticleDiameter)
        {
            MaxParticleDiameter = diamUpper;
        }
    }

    //Same loop for reading in CNT filler data from input file (NOT YET DEVELOPED)
    for (int i = 0; i < NumCNTFillers; i++)
    {
        //Read CNT data
    }

    //Define temporary containers for reading/converting input data from Input_Parameters.txt file
    //regarding the polymer/matrix properties
    long double PolymerBarrierHeight;
    int TunnelingDist;
    float p;
    fin >> rho >> PolymerBarrierHeight >> TunnelingDist >> p;
    
    //Initialize the polymer data object
    p_data.initialize(rho, PolymerBarrierHeight, TunnelingDist, p, d);
    
    //Define the tunneling distance in units of nanometers by scaling via the mult variable
    Td = TunnelingDist*mult;
    
    //Determine quantity of each particle type based on weight percentage
    float Wp = 1;       //start Wp variable at 100%
    for (int i = 0; i < MassFractionOfFillers.size(); i++)
    {
        Wp -= MassFractionOfFillers[i]/100.0;      //reduced Wp by mass fraction occupied by filler particles
    }
    long double cells = Xbound*Ybound*Zbound;   //Calculate total number of unit cells in RVE
    long double Vrve = cells * (pow(d, 3));     //volume of RVE in nm^3
    
    //Initialize the All_Indices container (container description in RVEdata.h) and all sparse
    //matrices contained within
    for (int t = 0; t <= Xbound; t++)
    {
        All_Indices.push_back(Eigen::SparseMatrix<double, Eigen::ColMajor>(Ybound+1, Zbound+1));
    }
    
    //Find density of composite using weight fractions https://nptel.ac.in/courses/101106038/mod03lec01.pdf
    double CompRho = Wp/p_data.GetDensity();
    for (int i = 0; i < NumCBFillers; i++)
    {
        CompRho += (MassFractionOfFillers[i]/100.0)/CB_data[i].GetDensity();
    }
    
    //Create running indices for keeping track of what each particles global index is
    long int particle_count = 0;
    long int CB_count = 0;
    long int CNT_count = 0;

    //The Total_Num_Particles variable is used in multiple functions. For a single particle type system,
    //the usage of this variable is for determining how many particles are to be placed as random aggregates,
    //as forced aggregates, and as forced agglomeraion individual particles. For multi-particle systems, this
    //usage will need to be modified in multiple locations throughout this file specifically.
    Total_Num_Particles = 0;
    
    //Loop through all CBFiller types to initialize the particle objects
    for (int i = 0; i<NumCBFillers; i++)
    {
        //Add the number of particles of CB type i needed
        NumParticles.push_back(round((MassFractionOfFillers[i]/100.0)*Vrve*(1.0/CompRho)/CB_data[i].GetAvgParticleWeight(d)));
        
        //Loop used to create the particle objects for each individual particle to be placed in the RVE
        for (long int j = 0; j < NumParticles[i]; j++)
        {
            //Add and initialize a particle_data object for each new particle
            particle_data.emplace_back();
            particle_data[particle_count].Initialize(i, CB_count, particle_count);
            
            //Add and intialize a CB_particle object for each new particle
			CB_particles.emplace_back();
			CB_particles[CB_count].Initialize(CB_count, i, CB_data[i].GetRandomRadius(), round(d/pow(10,-9)));
            
            //increment the running indices
			CB_count += 1;
            particle_count += 1;
        }
        //For each CB_data object, set the number of particles private object variable
        CB_data[i].SetNumParticles(NumParticles[i]);
        
        //Increment the Total_num_particles variable by the # of particles initialized in the loop iteration
        Total_Num_Particles += NumParticles[i];
    }
    
    //Define bit-fields for global shell and potential maps
    Potential.resize((Xbound+1)*(Ybound+1)*(Zbound+1));
    Potential.reset();
    Shell.resize((Xbound+1)*(Ybound+1)*(Zbound+1));
    Shell.reset();
    
    //Loop for initializing CNT particles (NOT YET DEVELOPED)
    for (int i = 0+NumCBFillers; i<NumCBFillers+NumCNTFillers; i++)
    {
        /*
        NumParticles.push_back(round((MassFractionOfFillers[i]/100.0)*Vrve*(1.0/CompRho)/CNT_data[i].GetAvgParticleWeight()));
        CB_data[i].SetNumParticles(NumParticles[i]);
        
         //Someday we will add CNT to this simulation!!!
        */
    }
}

//Function to read in aggregate files and store aggregate data for simulation
void RVEdata::Read_Agg_Files()
{
    //Define current working directory where executable is being run (cwd)
    std::string cwd = getcwd(NULL,0);
    
    //The aggregate files are located in a subdirectory cwd/Agg_Files/..
    std::string dir = cwd + "/Agg_Files/";
    
    //This algorithm uses boost to parse the files in the subdir, first define the path
    boost::filesystem::path p(dir);
    
    //Create vector for storing all the aggregate coordinate file names
    std::vector<std::string> file_names;
    
    //Loop through the Agg_Files subdirectory to pull out aggregate file names to be used in simulation
    for (auto i = boost::filesystem::directory_iterator(p); i != boost::filesystem::directory_iterator(); i++)
    {
        //If entry [i] is a directory, skip
        if (boost::filesystem::is_directory(i->path()))
        {
            continue;
        }
        else
        {
            //If entry string begins with a period skip
            if (i->path().filename().string()[0] == '.')
            {
                continue;
            }
            //If entry string does not begin with a "_", add filename to vector
            if (i->path().filename().string()[0] != '_')
            {
                file_names.push_back(i->path().filename().string());
            }
        }
    }
    
    //Loop through gathered filenames to read aggregate coordinates
    for (int i = 0; i < file_names.size(); i++)
    {
        //Define input file stream
        std::ifstream Agg_file;
        
        //Open the file
        Agg_file.open(dir + file_names[i]);
        
        //Create temp vectors for relative coordinates and translated coordinates
        std::vector<std::vector<int> > temp_agg_xyz;
        std::vector<std::vector<int> > translated_agg_xyz;
        
        //First row of the file is the number of coordinate sets in the file (hence "num")
        int num;
        Agg_file >> num;
        
        //Create temp string containers to read from file
        std::string x="", y="", z="", r="";
        std::string line;
        
        //Ignore second two lines
        std::getline(Agg_file,line);
        std::getline(Agg_file,line);
        
        //The aggregate coordinate files have a wide range of possible coordinates that are of double precision.
        //These aggregates must be converted to integers. We also need to determine the particle with the lowest
        //mapped index. Coordinate (0,0,0)'s index 0. coordinate (0,1,0)'s index is 1, coordinate (0,0,1)'s index
        //is equal to the RVE y length divided by the RVE unit length. Coordinate (1,0,0)'s index is equal to the
        //RVE Z length [unit length] * RVE Y length [unit length]. Using this indexing scheme, we want to know the
        //particle in the aggregate that will be the lowest index when translated to our RVE global scheme. This
        //particle will have the minimum x, y, and z coordinates, and will be used as a reference particle. Also,
        //we want to determine the maximum bounding box to contain this aggregate for bounds checking with the
        //global RVE during placement.
        //Define integers for determining the maximum/minimum x, y, and z coordinates of the aggregate
        int xi=0, yi=0, zi=0, ri=0;
        int minx=100, miny=100, minz=100, maxx=-100, maxy=-100, maxz=-100;
        
        //While loop to parse through aggregate file lines to end-of-file
        while (std::getline(Agg_file,line))
        {
            std::istringstream s(line);
            //parse line using std::ws which removes white space between line items
            s >> x >> std::ws >> y >> std::ws >> z >> std::ws >> r;
            //convert strings to integers
            xi = std::stoi(x);
            yi = std::stoi(y);
            zi = std::stoi(z);
            ri = std::stoi(r);
            //If statements to determine if coordinates are min/max
            if (xi > maxx){ maxx = xi;}
            if (yi > maxy){ maxy = yi;}
            if (zi > maxz){ maxz = zi;}
            if (xi < minx){ minx = xi;}
            if (yi < miny){ miny = yi;}
            if (zi < minz){ minz = zi;}
            //Add particle coordinates to temporary list of coordinates
            temp_agg_xyz.push_back(std::vector<int> {xi, yi, zi});
        }
        //Define no_p_per_agg (# of particles per aggregate) via size of temp agg list
        if (i == 0){no_p_per_agg = temp_agg_xyz.size();}
        //Loop through temp agg list and translate coordinates using axes minimums determined above
        for (int j = 0; j < temp_agg_xyz.size(); j++)
        {
            translated_agg_xyz.push_back(std::vector<int> {temp_agg_xyz[j][0]-minx, temp_agg_xyz[j][1]-miny, temp_agg_xyz[j][2]-minz});
        }
        //Push back vector of primary particle coordinates into a bank
        Agglomerates.push_back(translated_agg_xyz);
        
        //Assign relative indices to each particle in the aggregate based off a reference index.
        //The reference index (Index 0) is coincident with the minimum coordinates of the bounding box.
        //This relative index map allows for rapid integration of aggregate into global index scheme.
        std::vector<long int> temp_indices;
        //Loop through each aggregate coordinate set
        for (int j = 0; j < translated_agg_xyz.size(); j++)
        {
            //This formula translates an XYZ coordinate set into a single index.
            long int index = ((Ybound+1)*(Zbound+1)*translated_agg_xyz[j][0]) + ((Ybound+1)*translated_agg_xyz[j][2]) + translated_agg_xyz[j][1];
            //Check to see if something is broken. Index < 0 should not be possible.
            if (index < 0)
            {
                std::cout << "index<0: " << index << ", xyz - " << translated_agg_xyz[j][0] << "," << translated_agg_xyz[j][1] << "," << translated_agg_xyz[j][2] << std::endl;
            }
            temp_indices.push_back(index);
        }
        //Add vector of relative indices to the bank of stored aggregate data
        Agglomerates_Indices.push_back(temp_indices);
        //Add aggregate bounding data to the bank of stored aggregate data for bounds checking
        Agglomerates_Bounds.push_back(std::vector<int> {maxx-minx, maxy-miny, maxz-minz});
    }
}

int RVEdata::GetNumParticles()
{
    return particle_data.size();
}

int RVEdata::GetNumCBFillers()
{
    return NumCBFillers;
}

void RVEdata::Build_RVE()
{
    //Determine number of available processors for threading
    int NumProcessors = std::thread::hardware_concurrency()*2;
	
    //Determine number of seed particles to be placed
    long int num_rand = ceil(Total_Num_Particles*Pct_Rand);
    
    //Error checking. num_rand must be greater than zero. If not, exit program.
    if (num_rand == 0)
    {
        std::cout << "ZERO RAND ERR: Pct_Rand = " << Pct_Rand << " TotalNum = " << Total_Num_Particles << std::endl;
        exit(1);
    }

    //Initialize the placement mapping variables
    Initialize_CB_Potential_Shell_Maps();
    Initialize_CB_Strain_Potential_Maps();
    
    //Place the seed aggregates in the RVE
    Place_Rand_Agglomerates(num_rand);
    
    //Place the forced agglomeration aggregates in the RVE
    Place_Forced_Agglomerates(num_rand);
    
    //Place the remainder of the particles individually in forced agglomeration
    Place_Remainder(num_rand);
    
    //*****************************************************************************/
    /************************** RVE Validation Output Code ************************/
    //*****************************************************************************/
    /*
    //Output potential and shell maps for checking. Files get really huge really quick
    std::ofstream check;
    check.open("check.csv");
    check << Total_Num_Particles << std::endl << std::endl;
    for (int i = 0; i < Total_Num_Particles; i++)
    {
        check << GetCBParticle(i)->GetXCoordinate() << " " << GetCBParticle(i)->GetYCoordinate() << " " << GetCBParticle(i)->GetZCoordinate() << " " << 15 << std::endl;
    }
    check.close();*/
    
    //Output coordinates for checking and comparing the things to the things
    /*
    std::ofstream check;
    check.open("check1.csv");
    check << num_rand + 1 + Potential.count() << std::endl << std::endl;
    for (int i = 0; i < num_rand; i++)
    {
        check << GetCBParticle(i)->GetXCoordinate() << " " << GetCBParticle(i)->GetYCoordinate() << " " << GetCBParticle(i)->GetZCoordinate() << " " << 15 << " " << 0 << std::endl;
    }
    
    check << GetCBParticle(num_rand)->GetXCoordinate() << " " << GetCBParticle(num_rand)->GetYCoordinate() << " " << GetCBParticle(num_rand)->GetZCoordinate() << " " << 15 << " " << 100 << std::endl;
    
    long int counter = 0;
    for (int i = 0; i <= Xbound; i++)
    {
        for (int k = 0; k <= Zbound; k++)
        {
            for (int j = 0; j <= Ybound; j++)
            {
                if (Potential[counter] == 1)
                {
                    check << i << " " << j << " " << k << " " << 0.5 << " " << 0 << std::endl;
                }
                counter++;
            }
        }
    }
    check.close();*/
    /*****************************************************************************/
}

void RVEdata::Place_Rand_Agglomerates(long int num_rand)
{
    //This function places the seed aggregates in the RVE commensurate with the desired
    //random pct variable.
    
    //Initialize random number generator instance using concatenated pid and time seed
    // Convert both the integers to string
    std::string s1 = std::to_string(time(NULL));
    std::string s2 = std::to_string(getpid());
    
    // Concatenate both strings
    std::string s = s1 + s2;
    
    // Convert the concatenated string to integer
    long int c = std::stol(s);
    
    //Initialize random seed and mersenne twister generator
    srand(c);
    std::mt19937_64 gen(rand());
    
    //Initialize uniform integer distribution list covering range of possible indices in the RVE
    std::uniform_int_distribution<long int> XYZ(0, Potential.size());
    
    //Initialize uniform integer distribution list covering the total number of aggregate files
    //that were previously read in for placement.
    std::uniform_int_distribution<int> Num_Agglomerates(0,Agglomerates.size()-1);
    
    //Create temporary vector storing a list of indices that have been checked and rejected
    //as valid placements for the next seed aggregate.
    std::vector<long int> Checked;
    
    //Define a few temporary integers for storing placement information
    long int next_index;
    int next_agglomerate;
    
    //Define the number of random (seed) aggregates to be placed according to the Pct rand user
    //input variable. Since particles are placed in aggregate form in multiples of no_p_per_agg,
    //the value is rounded.
    num_rand_agg = floor((Total_Num_Particles*Pct_Rand)/no_p_per_agg);
    
    //If num_rand_agg is zero, this will cause failure. Instead make it equal to one.
    if (num_rand_agg == 0)
    {
        num_rand_agg = 1;
    }
    
    //Variable used to keep track of the index of the particle currently being processed.
    running_index = 0;
    
    //Loop to place num_rand_agg aggregates in the RVE at random locations
    for (long int i = 0; i < num_rand_agg; i ++)
    {
        //Boolean used to signal when successful placement has occured
        bool Good = false;
        
        //Integer used to keep track of how many times placement failed
        int total_iter = 0;
        
        //Pick random aggregate index from the list of aggregate indices
        next_agglomerate = Num_Agglomerates(gen);
        
        //While loop to continue attempting to place aggregate until (a) the process has been failed
        //too many times or (b) the process was successfully completed
        while (Good == false)
        {
            //Boolean used to signal whether the placement was validated successfully
            bool Already_Checked = false;
            
            //Loop to attempt placement at random locations until a valid location is chosen.
            while(Already_Checked == false)
            {
                //Set next_index to a random index in the RVE. This is the reference index for the aggregate.
                //The reference index of the aggregate is coincident with (min(x), min(y), min(z)) of the
                //aggregate system.
                next_index = XYZ(gen);
                
                //Determine the coordinates of the reference index of the aggregate
                int x, y, z, x_max, y_max, z_max;
                x = floor(next_index/((Ybound+1)*(Zbound+1)));
                z = floor((next_index-(x*(Ybound+1)*(Zbound+1)))/(Ybound+1));
                y = next_index - (x*(Ybound+1)*(Zbound+1)) - (z*(Ybound+1));
                
                //Define the maximum coordinates bounding the aggregate W.R.T the global system
                x_max = x + Agglomerates_Bounds[next_agglomerate][0];
                y_max = y + Agglomerates_Bounds[next_agglomerate][1];
                z_max = z + Agglomerates_Bounds[next_agglomerate][2];
                
                //Check the max coordinates of the aggregate to make sure they aren't outside the RVE.
                if (x_max > Xbound || y_max > Ybound || z_max > Zbound)
                {
                    //If the max are outside the RVE, add this index to the list of unsuccessful
                    //placement indices attempted and try again.
                    Checked.push_back(next_index);
                    continue;
                }
                
                //Loop through the Checked vector to see if this index has been attempted before
                for (int k = 0; k < Checked.size(); k++)
                {
                    //If this index has been checked, break the loop and get a new index
                    if (next_index == Checked[k]){ break;}
                    //If we reach the end of Checked without breaking the loop, move on to check
                    //the validity of the placement relative to other particles in the RVE.
                    if (k == Checked.size()-1){ Already_Checked = true;}
                }
            }
            
            //Loop through the aggregate indices and check the shell maps to make sure the individual
            //particles aren't interferring with previously existing particles in the RVE
            for (int j = 0; j < Agglomerates[next_agglomerate].size(); j++)
            {
                //The index in question is relative to the reference index of the aggregate (hence
                // the formulation next_index + Agglomerate_Indices...).
                if (Shell[next_index + Agglomerates_Indices[next_agglomerate][j]] == 1)
                {
                    //If the global index in the Shell map bit-field contains a 1, that means
                    //the aggregate placement index would cause interference. Break the loop and
                    //pick a new random index to place the aggregate.
                    Checked.push_back(next_index);
                    break;
                }
                //If we made it this far, this means all the individual particles in the aggregate were
                //found to be validly placed. This means we can turn the placement boolean Good to true
                //and finalize the placement of the aggregate.
                if (j == Agglomerates_Indices[next_agglomerate].size()-1)
                {
                    Good = true;
                }
            }
            
            //Once placement is found to be valid (Good == true), save the individual particle data and
            //update the global RVE potential/shell maps
            if (Good == true)
            {
                //Clear the temporary Checked vector
                Checked.clear();
                
                //Loop through each particle in the aggregate for saving/updating global data
                for (int z = 0; z < Agglomerates_Indices[next_agglomerate].size(); z++)
                {
                    //Call the particle index initialization function
                    Initialize_Index(next_index + Agglomerates_Indices[next_agglomerate][z], running_index);
                    
                    //Call the map updating function
                    Map_CB(running_index);
                    
                    //Increment running index
                    running_index += 1;
                }
            }
        }
    }
}

void RVEdata::Place_Forced_Agglomerates(long int num_rand)
{
    //This function places aggregates in the RVE under a forced agglomeration condition. The number
    //of forced aggregates placed is defined by the user defined Fill % variable
    
    //Initialize random number generator instance using concatenated pid and time seed
    // Convert both the integers to string
    std::string s1 = std::to_string(time(NULL));
    std::string s2 = std::to_string(getpid());
    
    // Concatenate both strings
    std::string s = s1 + s2;
    
    // Convert the concatenated string to integer
    long int c = std::stol(s);
    
    //Initialize random seed and mersenne twister generator
    srand(c);
    std::mt19937_64 gen(rand());
    
    //Initialize uniform integer distribution list covering range of possible indices in the RVE
    std::uniform_int_distribution<long int> XYZ(0, Potential.size());
    
    //Initialize uniform integer distribution list covering the total number of aggregate files
    //that were previously read in for placement.
    std::uniform_int_distribution<int> Num_Agglomerates(0,Agglomerates.size()-1);
    
    //Create temporary vector storing a list of indices that have been checked and rejected
    //as valid placements for the next seed aggregate.
    std::vector<long int> Checked;
    
    //Define a few temporary integers for storing placement information
    long int next_index;
    int next_agglomerate;
    
    //Define the number of forced aggregates to be placed according to the Pct_Fill user
    //input variable. Since particles are placed in aggregate form in multiples of no_p_per_agg,
    //the value is rounded.
    num_forced_agg = floor(((Total_Num_Particles - (floor((Total_Num_Particles*Pct_Rand)/no_p_per_agg)*no_p_per_agg))*(1.-Pct_Fill))/no_p_per_agg);
    
    //Loop to place num_forced_agg aggregates in the RVE under forced agglomeration condition
    for (long int i = 0; i < num_forced_agg; i ++)
    {
        //Boolean used to signal when successful placement has occured
        bool Good = false;
        
        //Integer used to keep track of how many times placement failed
        int total_iter = 0;
        
        //Pick random aggregate index from the list of aggregate indices
        next_agglomerate = Num_Agglomerates(gen);
        
        //While loop to continue attempting to place aggregate until (a) the process has been failed
        //too many times or (b) the process was successfully completed.
        while (Good == false)
        {
            //Boolean used to signal whether the placement was validated successfully
            bool Already_Checked = false;
            
            //Loop to attempt placement at random locations until a valid location is chosen.
            while(Already_Checked == true)
            {
                //Set next_index to a random index in the RVE. This is the reference index for the aggregate.
                //The reference index of the aggregate is coincident with (min(x), min(y), min(z)) of the
                //aggregate system.
                next_index = XYZ(gen);
                
                //Determine the coordinates of the reference index of the aggregate
                int x, y, z, x_max, y_max, z_max;
                x = floor(next_index/((Ybound+1)*(Zbound+1)));
                z = floor((next_index-(x*(Ybound+1)*(Zbound+1)))/(Ybound+1));
                y = next_index - (x*(Ybound+1)*(Zbound+1)) - (z*(Ybound+1));
                
                //Define the maximum coordinates bounding the aggregate W.R.T the global system
                x_max = x + Agglomerates_Bounds[next_agglomerate][0];
                y_max = y + Agglomerates_Bounds[next_agglomerate][1];
                z_max = z + Agglomerates_Bounds[next_agglomerate][2];
                
                //Check the max coordinates of the aggregate to make sure they aren't outside the RVE.
                if (x_max > Xbound || y_max > Ybound || z_max > Zbound)
                {
                    //If the max are outside the RVE, add this index to the list of unsuccessful
                    //placement indices attempted and try again.
                    Checked.push_back(next_index);
                    continue;
                }
                
                //Loop through the Checked vector to see if this index has been attempted before
                for (int k = 0; k < Checked.size(); k++)
                {
                    //If this index has been checked, break the loop and get a new index
                    if (next_index == Checked[k]){ break;}
                    //If we reach the end of Checked without breaking the loop, move on to check
                    //the validity of the placement relative to other particles in the RVE.
                    if (k == Checked.size()-1){ Already_Checked = false;}
                }
            }
            
            //Loop through the aggregate indices and check the shell maps to make sure the individual
            //particles aren't interferring with previously existing particles in the RVE. To force
            //agglomeration, at least one particle must have a neighboring relationship created with
            //a previously existing particle in the RVE. Once a neghbor is found, the flag is updated.
            bool Got_Neighbors = false;
            for (int j = 0; j < Agglomerates[next_agglomerate].size(); j++)
            {
                //The index in question is relative to the reference index of the aggregate (hence
                // the formulation next_index + Agglomerate_Indices...).
                if (Shell[next_index + Agglomerates_Indices[next_agglomerate][j]] == 1)
                {
                    //If the global index in the Shell map bit-field contains a 1, that means
                    //the aggregate placement index would cause interference. Break the loop and
                    //pick a new random index to place the aggregate.
                    Checked.push_back(next_index);
                    break;
                }
                //Check to see if the new particle index would be in a neighbroing relationship via
                //the Potential bit-field.
                if (Potential[next_index + Agglomerates_Indices[next_agglomerate][j]] == 1)
                {
                    //The particle would have a neighbor if placed at the index. Change the flag.
                    Got_Neighbors = true;
                }
                //If we made it this far, this means all the individual particles in the aggregate were
                //found to be validly placed. This means we can turn the placement boolean Good to true
                //and finalize the placement of the aggregate.
                if (j == Agglomerates_Indices[next_agglomerate].size()-1 && Got_Neighbors == true)
                {
                    Good = true;
                }
            }
            
            //Once placement is found to be valid (Good == true && Got_Neighbors ==true), save the
            // individual particle data and update the global RVE potential/shell maps
            if (Got_Neighbors == true && Good == true)
            {
                //Clear the temporary Checked vector
                Checked.clear();
                
                //Loop through each particle in the aggregate for saving/updating global data
                for (int z = 0; z < Agglomerates_Indices[next_agglomerate].size(); z++)
                {
                    //Call the particle index initialization function
                    Initialize_Index(next_index + Agglomerates_Indices[next_agglomerate][z], running_index);
                    
                    //Call the map updating function
                    Map_CB(running_index);
                    
                    //Increment running index
                    running_index += 1;
                }
            }
        }
    }
}

void RVEdata::Place_Remainder(long int num_rand)
{
    //This function places individual particles in the RVE under a forced agglomeration condition.
    //The number of individual particles placed is defined by the user defined Fill % variable
    
    //Initialize random number generator instance using concatenated pid and time seed
    // Convert both the integers to string
    std::string s1 = std::to_string(time(NULL));
    std::string s2 = std::to_string(getpid());
    
    // Concatenate both strings
    std::string s = s1 + s2;
    
    // Convert the concatenated string to integer
    long int c = std::stol(s);
    
    //Initialize random seed and mersenne twister generator
    srand(c);
    std::mt19937_64 gen(rand());
    
    //Initialize uniform integer distribution list covering range of possible indices in the RVE
    std::uniform_int_distribution<long int> XYZ(0, Potential.size());
    
    //Define the number of particles to be placed to meet the desired weight %
    int num_remaining = Total_Num_Particles - ((num_rand_agg+num_forced_agg)*no_p_per_agg);
    long int next_index;
    
    //Loop to place the rest of the particles in the RVE under forced agglomeration condition
    for (long int i = Total_Num_Particles-num_remaining; i < Total_Num_Particles; i ++)
    {
        //Boolean used to signal when successful placement has occured
        bool Good = false;
        
        //Integer used to keep track of how many times placement failed
        int total_iter = 0;
        
        //While loop to continue attempting to place aggregate until (a) the process has been failed
        //too many times or (b) the process was successfully completed.
        while (Good == false)
        {
            //Set next_index to a random index in the RVE. This is the index of the center of the
            //particle to be placed
            next_index = XYZ(gen);
            
            //If the particle is placed at an index that containes a 1 in the Potential bit-field,
            //that means the particle will have at least one neighbor.
            if (Potential[next_index] == 1)
            {
                //Forced agglomeration condition satisfied, change the flag
                Good = true;
            }
            
            //Increment the iteration counter
            total_iter ++;
            
            //If the number of attempts is great, something might be wrong
            if (total_iter > 10000000)
            {
                //Print that the iteration threshold has been reached, and the system will be
                //checked for fullness and error potential.
                std::cout << "Max Iter: " << total_iter << std::endl;
                long int sum_ones = 0;
                for (long int z=0; z < Potential.size(); z++)
                {
                    if (Potential[z] ==1)
                    {
                        sum_ones += 1;
                    }
                }
                //Output the status of the Potential bit-field and exit the code
                std::cout << "sum_ones in Potential = " << sum_ones << std::endl;
                exit(1);
            }
        }
        //Call the particle index initialization function
        Initialize_Index(next_index, i);
        
        //Call the map updating function
        Map_CB(i);
    }
}

void RVEdata::Get_Next_Location(long int &next)
{
    //Check if "next" is a valid placement
    if (Potential[next] == 1) { return;}
    
    //Check up to last index and return once a valid placement is found
    for (long int i = next; i < Potential.size(); i++)
    {
        if (Potential[i] == 1) { next = i; return;}
    }
    
    //If arrived here, need to start over at first (0th) index
    for (long int i = 0; i < next; i++)
    {
        if (Potential[i] == 1) { next = i; return;}
    }
    
    //If got all the way here, either the thing is full or something's wrong
    std::cout << "RVE FULL or WORSE... THERE'S A BUG!\n";
    exit(1);
}

void RVEdata::Initialize_Index(long int next_index, long int ID)
{
    //Create temporary integers for determining/storing coordinates
    int x, y, z;
    x = floor(next_index/((Ybound+1)*(Zbound+1)));
    z = floor((next_index-(x*(Ybound+1)*(Zbound+1)))/(Ybound+1));
    y = next_index - (x*(Ybound+1)*(Zbound+1)) - (z*(Ybound+1));
    
    //Call function from CB Paritcle object to set the coordinates of the particle
    GetCBParticle(GetParticle(ID)->GetTypeID())->SetXYZ(x, y, z, Xbound, Td);
}

void RVEdata::Map_CB(long int CB)
{
    //This function updates the potential/shell bit-fields with the newly placed particle influence
    
    //Get CB Particle Diameter and coordinates from CBParticle object instance
    int diam = GetCBParticle(CB)->GetDiameter();
    int x = GetCBParticle(CB)->GetXCoordinate();
    int y = GetCBParticle(CB)->GetYCoordinate();
    int z = GetCBParticle(CB)->GetZCoordinate();
    
    //Add index to the deque of indices for future neighbor finding algorithm
    All_Indices[x].coeffRef(y,z) = CB;
    
    //Determine the index of the particle based on the coordinates
    long int CB_index = ((Ybound+1)*(Zbound+1)*x) + ((Ybound+1)*z) + y;
    
    //Set the CBParticle private object index variable
    GetCBParticle(CB)->Set_Index(CB_index);
    
    //Determine which map to use for the CB particle through the object function call
    int which_set = Get_CB_Map_Index(CB);
    
    //Temproarily define the maximum index of the RVE for bounds checking
    long int max_index = Potential.size();
    
    //This loop goes through each index of the CB_potential_map and changes the Potential bit-fields
    //to reflect the particle being placed in the RVE creating "new potential" for future agglomeration
    long int which_index;
    for (int i = 0; i < CB_Potential_Maps_Indices[which_set].size(); i++)
    {
        //The CB_Potential_Maps contain indices that are relative to the reference index (the index
        //located at the center of particle). which_index is translated to the global RVE.
        which_index = CB_index + CB_Potential_Maps_Indices[which_set][i];
        
        //Check to make sure the mapped index coordinates exist within the bounds of the RVE. If the
        //coordinates of the mapped index are outside the RVE, that index is skipped.
        if (x + CB_Potential_Maps_X[which_set][i] > Xbound || x + CB_Potential_Maps_X[which_set][i] < 0) {continue;}
        if (y + CB_Potential_Maps_Y[which_set][i] > Ybound || y + CB_Potential_Maps_Y[which_set][i] < 0) {continue;}
        if (z + CB_Potential_Maps_Z[which_set][i] > Zbound || z + CB_Potential_Maps_Z[which_set][i] < 0) {continue;}
        
        //If the index is greater than the max index, the index is skipped.
        if (which_index > max_index) {continue;}
        
        //If Shell global map contains a 1 at that index, another particle is making that mapped index
        //an invalid location. Therefore the index of the potential map is not modified.
        if (Shell[which_index] == 1) {continue;}
        
        //Once this point is reached, the addition of a 1 in Potential[which_index] is valid.
        Potential[which_index] = 1;
    }
    
    //This loop goes through each index of the CB_Shell_map and changes the Shell bit-fields
    //to reflect the particle being placed in the RVE creating "new interferences" for
    //future particles to be placed
    for (int i = 0; i < CB_Shell_Maps_Indices[which_set].size(); i++)
    {
        //The CB_Potential_Maps contain indices that are relative to the reference index (the index
        //located at the center of particle). which_index is translated to the global RVE.
        which_index = CB_index + CB_Shell_Maps_Indices[which_set][i];
        
        //Check to make sure the mapped index coordinates exist within the bounds of the RVE. If the
        //coordinates of the mapped index are outside the RVE, that index is skipped.
        if (x + CB_Shell_Maps_X[which_set][i] > Xbound || x + CB_Shell_Maps_X[which_set][i] < 0) {continue;}
        if (y + CB_Shell_Maps_Y[which_set][i] > Ybound || y + CB_Shell_Maps_Y[which_set][i] < 0) {continue;}
        if (z + CB_Shell_Maps_Z[which_set][i] > Zbound || z + CB_Shell_Maps_Z[which_set][i] < 0) {continue;}
        if (which_index > max_index) {continue;}
        
        //Once this point is reached, the addition of a 1 in Shell[which_index] is valid. Also, we update
        //the Potential[which_index] container to 0 to deem that location NOT valid for future placement.
        Shell[which_index] = 1;
        Potential[which_index] = 0;
    }
}

int RVEdata::Get_CB_Map_Index(long int ID)
{
    //Return the index to the correct map for the particular particle corresponding to its size
    int type = CB_particles[particle_data[ID].GetTypeID()].GetMatType();
    int diam = CB_particles[particle_data[ID].GetTypeID()].GetDiameter();
    
    //If there are multiple diameters for the CBMaterial (i.e. polydispersity), we have to determine
    //which map to use based on the particle's diameter. For the monodisperse implementations of
    //the code (2021-2022 papers), this loop returns 0.
    int count = 0;
    for (int i = 0; i < type; i++)
    {
        count += CB_data[i].GetMaxDiameter() - CB_data[i].GetMinDiameter();
    }
    count += diam - CB_data[type].GetMinDiameter();
    return count;
}

int RVEdata::Get_Max_CB_Map_Index(long int ID)
{
    //Return the index to the correct map for the particular particle corresponding to its size
    int type = CB_particles[particle_data[ID].GetTypeID()].GetMatType();
    int diam = CB_data[type].GetMaxDiameter();
    
    //If there are multiple diameters for the CBMaterial (i.e. polydispersity), we have to determine
    //which map to use based on the particle's diameter. For the monodisperse implementations of
    //the code (2021-2022 papers), this loop returns 0.
    int count = 0;
    for (int i = 0; i < type; i++)
    {
        count += CB_data[i].GetMaxDiameter() - CB_data[i].GetMinDiameter();
    }
    count += diam - CB_data[type].GetMinDiameter();
    return count;
}

void RVEdata::Initialize_CB_Potential_Shell_Maps()
{
    //This function initializes containers that are used in mapping  CB particles into
    //the gloabl RVE. Two types of maps are created for each CB type: The potential map, and
    //the shell map. The potential map is used to determine which indices (surrounding a
    //reference index) have the "potential" to create neighboring relationships with the particle
    //located at the reference index. The shell map is used to determine which indices surrounding
    //the reference index are invalid as a consequnece of their near proximity to the reference index.
    //The maps are stored as vectors of 1-D arrays of integers for corresponding coordinates and indices.
    
    //Loop through each filler and add the mapping scheme for each particle size for each type
    int Map_Count = 0;
    for (int x = 0; x < NumCBFillers; x++)
    {
        //For each diameter of each particle type create a new map. In 2021-22 papers, only one diameter
        //is used (30-nm). Further coding efforts needed for polydisperse systems.
        for (int y = 0; y <= GetCBMatType(x)->GetMaxDiameter() - GetCBMatType(x)->GetMinDiameter(); y++)
        {
            //Get minimum diameter of particle type. This command is specific to the monodisperse case.
            double diam = (GetCBMatType(x)->GetMinDiameter() + y)*mult;
            
            //The maximum allowable particle-particle penetration in distance of nm
            int PS = GetCBMatType(x)->GetPenetrationAllowance()*mult;

            //Define the maximum principal coordinates of the bounding box for the map.
            int xb = diam*2 ;
            int yb = diam*2 ;
            int zb = diam*2 ;
            
            //Push back the vectors to create a "new map" instance
            CB_Potential_Maps_X.push_back(std::vector<int>(0));
            CB_Potential_Maps_Y.push_back(std::vector<int>(0));
            CB_Potential_Maps_Z.push_back(std::vector<int>(0));
            CB_Shell_Maps_X.push_back(std::vector<int>(0));
            CB_Shell_Maps_Y.push_back(std::vector<int>(0));
            CB_Shell_Maps_Z.push_back(std::vector<int>(0));
            CB_Potential_Maps_Indices.push_back(std::vector<long int>(0));
            CB_Shell_Maps_Indices.push_back(std::vector<long int>(0));

            //Index zero is defined as location (x0,y0,z0), which is coincident with the center
            //of the particle to be placed at index 0 of diameter = diam
            int x0 = diam;
            int y0 = diam;
            int z0 = diam;
            double dist;
            
            //Define the index of coordinate (0,0,0) using ths formula.
            long int index_0 = 0 - ((Ybound+1)*(Zbound+1)*x0) - ((Ybound+1)*z0) - (y0);
            long int zer = 0 - index_0;
            
            //In this set of nested loops, we will go through each index and check the seperation distance
            //from index0. If the distance is close enough to create a neighboring relationship, the index
            //is stored in the potential map containers. If the index is too close (creating interference)
            //the index is stored in the shell map containers. If neither is true, skip index.
            
            //The incrementing of the indices is important for consistent numbering. First we increment the
            //y-coordinate, then the z coordinate, then the x-coordinate. This is consistent with the index
            //numbering scheme deployed in the global system.
            for (int i = 0; i <= xb; i++)
            {
                for (int j = 0; j <= zb; j++)
                {
                    for (int k = 0; k <= yb; k++)
                    {
                        //Calculate distance between indices
                        dist = mult*pow(((abs(y0-k)*abs(y0-k)) + (abs(z0-j)*abs(z0-j)) + (abs(x0-i)*abs(x0-i))), 0.5);
                        if (dist < (diam + Td) || std::fabs(dist - diam - Td) < 0.000001)
                        {
                            if (dist > (diam-PS) || std::fabs(dist-diam+PS) < 0.000001)
                            {
                                //Index is close enough to form neighboring relationship
                                CB_Potential_Maps_X[Map_Count].push_back(i-x0);
                                CB_Potential_Maps_Z[Map_Count].push_back(j-z0);
                                CB_Potential_Maps_Y[Map_Count].push_back(k-y0);
                                CB_Potential_Maps_Indices[Map_Count].push_back(index_0);
                            }
                            else
                            {
                                //Index is too close and interference would occur
                                CB_Shell_Maps_X[Map_Count].push_back(i-x0);
                                CB_Shell_Maps_Z[Map_Count].push_back(j-z0);
                                CB_Shell_Maps_Y[Map_Count].push_back(k-y0);
                                CB_Shell_Maps_Indices[Map_Count].push_back(index_0);
                            }
                        }
                        //Increment the index_0 integer. This integer defines the index of (i,k,j)
                        index_0++;
                    }
                    //Increment the index_0 integer. This integer defines the index of (i,k,j). The
                    //increment for moving up a z-row is equal to the Y length of the subRVE
                    index_0 += ((Ybound+1) - yb - 1);
                }
                //Increment the index_0 integer. This integer defines the index of (i,k,j). The
                //increment for moving up a x-row is an even more complex equation.
                index_0 += ((Ybound+1)*(Zbound+1) - ((zb+1)*(Ybound+1)));
            }
            
            /***********************************************************************************/
            /******************* FOR IMAGE OUTPUT/DEBUGGING OF MAP *****************************/
            /***********************************************************************************/
            /*
            std::ofstream output;
            std::cout << "Map_Count = " << Map_Count << std::endl;
            output.open("map_" + std::to_string(Map_Count) + ".csv");
            output << CB_Potential_Maps_Indices[Map_Count].size() + CB_Shell_Maps_Indices[Map_Count].size() << std::endl << std::endl;
            for (int p = 0; p < CB_Potential_Maps_Indices[Map_Count].size(); p++)
            {
                output << x0+CB_Potential_Maps_X[Map_Count][p] << " " << y0+CB_Potential_Maps_Y[Map_Count][p] << " " << z0+CB_Potential_Maps_Z[Map_Count][p] << " 0.5 100 0 " << CB_Potential_Maps_Indices[Map_Count][p] + zer <<std::endl;
            }
            
            for (int p = 0; p < CB_Shell_Maps_Indices[Map_Count].size(); p++)
            {
                output << x0+CB_Shell_Maps_X[Map_Count][p] << " " << y0+CB_Shell_Maps_Y[Map_Count][p] << " " << z0+CB_Shell_Maps_Z[Map_Count][p] << " 0.5 0 100 " << CB_Shell_Maps_Indices[Map_Count][p] << std::endl;
            }
            
            output.close();
            */
            /***********************************************************************************/
            
            //Increment the map count integer and do the next map
            Map_Count++;
        }
    }
}

void RVEdata::Initialize_CB_Strain_Potential_Maps()
{
    //Loop through each filler and add the mapping scheme for each particle size for each type
    int Map_Count = 0;
    for (int x = 0; x < NumCBFillers; x++)
    {
        for (int y = 0; y <= GetCBMatType(x)->GetMaxDiameter() - GetCBMatType(x)->GetMinDiameter(); y++)
        {
            double diam = (GetCBMatType(x)->GetMinDiameter() + y)*mult;
            
            int PS = GetCBMatType(x)->GetPenetrationAllowance()*mult;
            
            int max_strain_dist = 6;          //must be an even integer
            int xb = diam*2 + max_strain_dist + (2*Td);
            int yb = diam*2 + max_strain_dist + (2*Td);
            int zb = diam*2 + max_strain_dist + (2*Td);
            
            CB_Strain_Potential_Maps_X.push_back(std::vector<int>(0));
            CB_Strain_Potential_Maps_Y.push_back(std::vector<int>(0));
            CB_Strain_Potential_Maps_Z.push_back(std::vector<int>(0));
            CB_Strain_Potential_Maps_Indices.push_back(std::vector<long int>(0));
            
            CB_Strain_Shell_Maps_X.push_back(std::vector<int>(0));
            CB_Strain_Shell_Maps_Y.push_back(std::vector<int>(0));
            CB_Strain_Shell_Maps_Z.push_back(std::vector<int>(0));
            CB_Strain_Shell_Maps_Indices.push_back(std::vector<long int>(0));
            
            int x0 = xb/2;  //+Td,
            int y0 = xb/2;  //+Td,
            int z0 = xb/2;  //+Td;
            double dist;
            
            long int index_0 = 0 - ((Ybound+1)*(Zbound+1)*x0) - ((Ybound+1)*z0) - (y0);
            long int zer = 0 - index_0;
            
            for (int i = 0; i <= xb; i++)
            {
                for (int j = 0; j <= zb; j++)
                {
                    for (int k = 0; k <= yb; k++)
                    {
                        dist = mult*pow(((abs(y0-k)*abs(y0-k)) + (abs(z0-j)*abs(z0-j)) + (abs(x0-i)*abs(x0-i))), 0.5);
                        if (dist < (diam + Td + max_strain_dist) || std::fabs(dist - diam - Td - max_strain_dist) < 0.000001)
                        {
                            if (dist > (diam-PS) || std::fabs(dist-diam+PS) < 0.000001)
                            {
                                CB_Strain_Potential_Maps_X[Map_Count].push_back(i-x0);
                                CB_Strain_Potential_Maps_Z[Map_Count].push_back(j-z0);
                                CB_Strain_Potential_Maps_Y[Map_Count].push_back(k-y0);
                                CB_Strain_Potential_Maps_Indices[Map_Count].push_back(index_0);
                            }
                            else
                            {
                                continue;
                            }
                        }
                        index_0++;
                    }
                    index_0 += ((Ybound+1) - yb - 1);
                }
                index_0 += ((Ybound+1)*(Zbound+1) - ((zb+1)*(Ybound+1)));
            }
            /************************************************************************************/
            /******************** FOR IMAGE OUTPUT/DEBUGGING OF MAP *****************************/
            /************************************************************************************/
            /*
            std::ofstream output;
            std::cout << "Map_Count = " << Map_Count << std::endl;
            output.open("strain-map_" + std::to_string(Map_Count) + ".csv");
            output << CB_Strain_Potential_Maps_Indices[Map_Count].size()+CB_Strain_Shell_Maps_Indices[Map_Count].size() << std::endl << std::endl;
            for (int p = 0; p < CB_Strain_Potential_Maps_Indices[Map_Count].size(); p++)
            {
                output << x0+CB_Strain_Potential_Maps_X[Map_Count][p] << " " << y0+CB_Strain_Potential_Maps_Y[Map_Count][p] << " " << z0+CB_Strain_Potential_Maps_Z[Map_Count][p] << " 0.5 100 0 " << CB_Strain_Potential_Maps_Indices[Map_Count][p] + zer <<std::endl;
            }
            
            for (int p = 0; p < CB_Strain_Shell_Maps_Indices[Map_Count].size(); p++)
            {
                output << x0+CB_Strain_Shell_Maps_X[Map_Count][p] << " " << y0+CB_Strain_Shell_Maps_Y[Map_Count][p] << " " << z0+CB_Strain_Shell_Maps_Z[Map_Count][p] << " 0.5 0 100 " << CB_Strain_Shell_Maps_Indices[Map_Count][p] + zer <<std::endl;
            }
            
            output.close();
            Map_Count++;
            */
            /************************************************************************************/
        }
    }
}

void RVEdata::Find_Neighbors()
{
    //This function is used to determine neighboring particle pairs after all particles have
    //been placed in the volume.
    
    //Count the # of processors for parallelization
    int num_processors = std::thread::hardware_concurrency();
    
    //Create a vector of std::future objects for parallelization of the search process
    std::vector<std::future<void> > Search;

    //Create temporary integer for assigning particle index tasks to processes
    long int index = 0;
    
    //Create integer to keep track of how many threads are active
    int Active_Threads = 0;
    
    //While loop to enforce search of neighboring relationships for all particles
    while (index < Total_Num_Particles)
    {
        //If the number of futures (threads) in the thread vector are less than the number of available
        //processes, then add another active thread instance.
        if (Search.size() < num_processors)
        {
            //This call initializes a thread tasked with finding the neighbors of the particle with ID=index
            Search.push_back(std::async(std::launch::async, &RVEdata::Check_Adjacent_Indices, this, index));
            //Increment the index variable to iniate the nieghbor search for the next particle of ID=index+1
            index++;
        }
        //If number of threads is maxed out, check to see if any threads have finished the search algorithm
        //and are available to be reassigned to a new task.
        else
        {
            //Loop through each process and check its status
            for (int i = 0; i < num_processors; i++)
            {
                //If index == Total_Num_Particles, that means we have gone through all the particles and
                //we don't need to assign anymore tasks.
                if (index == Total_Num_Particles) { break;}
                
                //Define the staus of the future[i] via the wait_for command
                auto status = Search[i].wait_for(std::chrono::nanoseconds(10));
                
                //If the status == ready, the thread has completed the search and is ready to be assigned
                //a new task.
                if (status == std::future_status::ready)
                {
                    //Assign the thread a new task and increment the index variable.
                    Search[i] = std::async(std::launch::async, &RVEdata::Check_Adjacent_Indices, this, index);
                    index++;
                }
            }
        }
    }
    
    //Once the while loop is broken, we need to wait for all the threads to finish their tasks.
    for (int i = 0; i < num_processors; i++)
    {
        Search[i].wait();
    }
}

void RVEdata::Find_Strained_Neighbors(float strain_elong)
{
    //Count the # of processors for parallelization
    int num_processors = std::thread::hardware_concurrency();
    
    float Poissons = p_data.GetPoissonsRatio();
    float eps1 = 1 + strain_elong;
    float eps2, eps3;
    if (Poissons != 0)
    {
        eps2 = 1 - (strain_elong*Poissons);
        eps3 = 1 - (strain_elong*Poissons);
    }
    else
    {
        eps2 = 1;
        eps3 = 1;
    }
    
    //Started at the bottom now we're here. Make the futures for parralelizatiomn.
    std::vector<std::future<void> > Search;
    long int num_rand = ceil(Total_Num_Particles*Pct_Rand);
    
    long int index = 0;
    int Active_Threads = 0;
    
    while (index < Total_Num_Particles)
    {
        if (Search.size() < num_processors)
        {
            Search.push_back(std::async(std::launch::async, &RVEdata::Check_Adjacent_Strain_Indices, this, index, eps1, eps2, eps3));
            index++;
            //std::cout << "Neighbors: " << index << "\r";
        }
        else
        {
            for (int i = 0; i < num_processors; i++)
            {
                if (index == Total_Num_Particles) { break;}
                auto status = Search[i].wait_for(std::chrono::nanoseconds(10));
                if (status == std::future_status::ready)
                {
                    Search[i] = std::async(std::launch::async, &RVEdata::Check_Adjacent_Strain_Indices, this, index, eps1, eps2, eps3);
                    index++;
                    //std::cout << "Neighbors: " << index << "\r";
                }
            }
        }
    }
    //std::cout << std::endl;
    
    //Wait for all the threads to finish up!
    for (int i = 0; i < num_processors; i++)
    {
        Search[i].wait();
    }
}

void RVEdata::Reset_Neighbors()
{
    for (long int i = 0; i < Total_Num_Particles; i++)
    {
        GetCBParticle(GetParticle(i)->GetTypeID())->Clear_Neighbors();
    }
}

void RVEdata::Check_Adjacent_Strain_Indices(long int i, float eps1, float eps2, float eps3)
{
    //Compare the distance of adjacent indices. Loop through the set of potential neighbor spots
    long int x = GetCBParticle(GetParticle(i)->GetTypeID())->GetXCoordinate();
    long int y = GetCBParticle(GetParticle(i)->GetTypeID())->GetYCoordinate();
    long int z = GetCBParticle(GetParticle(i)->GetTypeID())->GetZCoordinate();
    
    long int CB_index = ((Ybound+1)*(Zbound+1)*x) + ((Ybound+1)*z) + y;
    
    int iPSoftness, jPSoftness, dpi, dpj;
    double dist;
    
    int which_set = Get_Max_CB_Map_Index(i);
    long int which_index;
    long int max_index = Potential.size();
    
    for (int j = 0; j < CB_Strain_Potential_Maps_Indices[which_set].size(); j++)
    {
        //if (j == i) { continue;}
        long int p_ID;
        which_index = CB_index + CB_Strain_Potential_Maps_Indices[which_set][j];
        
        //Check the bounds of the potential map index
        if (x + CB_Strain_Potential_Maps_X[which_set][j] > Xbound || x + CB_Strain_Potential_Maps_X[which_set][j] < 0) {continue;}
        if (y + CB_Strain_Potential_Maps_Y[which_set][j] > Ybound || y + CB_Strain_Potential_Maps_Y[which_set][j] < 0) {continue;}
        if (z + CB_Strain_Potential_Maps_Z[which_set][j] > Zbound || z + CB_Strain_Potential_Maps_Z[which_set][j] < 0) {continue;}
        if (which_index > max_index) {continue;}
        //If passed the "if" statements, the index is within the RVE. Check it for a particle
        
        if(isNull(All_Indices[x+CB_Strain_Potential_Maps_X[which_set][j]], y+CB_Strain_Potential_Maps_Y[which_set][j], z+CB_Strain_Potential_Maps_Z[which_set][j]) == true)
        {
            //If == 0, then there is no particle at the index. Onto the next one!
            continue;
        }
        else
        {
            p_ID = All_Indices[x+CB_Strain_Potential_Maps_X[which_set][j]].coeffRef(y+CB_Strain_Potential_Maps_Y[which_set][j], z+CB_Strain_Potential_Maps_Z[which_set][j]);
        }
        
        int Particle_i_Type = GetParticle(i)->GetType();
        int Particle_j_Type = GetParticle(p_ID)->GetType();
        
        //Set particle softness of particle j
        if (Particle_i_Type <= NumCBFillers)
        {
            iPSoftness = GetCBMatType(GetCBParticle(GetParticle(i)->GetTypeID())->GetMatType())->GetPenetrationAllowance()*mult;
            dpi = GetCBParticle(GetParticle(i)->GetTypeID())->GetDiameter()*mult;
        }
        
        if (Particle_j_Type <= NumCBFillers)
        {
            jPSoftness = GetCBMatType(GetCBParticle(GetParticle(p_ID)->GetTypeID())->GetMatType())->GetPenetrationAllowance()*mult;
            dpj = GetCBParticle(GetParticle(p_ID)->GetTypeID())->GetDiameter()*mult;
        }
        
        //Define the most restrictive penetration allowance
        double PS;
        if (iPSoftness < jPSoftness)
        {
            PS = iPSoftness;
        }
        else
        {
            PS = jPSoftness;
        }
        
        dist = GetCBParticle(GetParticle(i)->GetTypeID())->FindStrainDistanceToNeighbor(GetCBParticle(GetParticle(p_ID)->GetTypeID()),eps1, eps2, eps3);
        
        // checking distance w.r.t the particle sizes and tunneling allowance
        if (dist < ((dpi+dpj)/2.0) + (Td) || std::fabs(dist - ((dpi+dpj)/2.0) - (Td)) < 0.000001)
        {
            //Checking interference allowance of most restrictive particle
            if (dist > (((dpi+dpj)/2.0)-(mult*PS)) || std::fabs(dist-(((dpi+dpj)/2.0)+(mult*PS))) < 0.000001)
            {
                GetCBParticle(GetParticle(i)->GetTypeID())->AddNeighbor(p_ID, dist);
            }
            else
            {
                std::cout << "TOO CLOSE WHAT?" << std::endl;
            }
        }
    }
}

void RVEdata::Check_Adjacent_Indices(long int i)
{
    //This function checks the surrounding indices of particle #i to determine if neighboring
    //relationships exist. Those relationships are stored for determination of RVE conductivity.
    
    //Get coordinates from CBParticle object
    long int x = GetCBParticle(GetParticle(i)->GetTypeID())->GetXCoordinate();
    long int y = GetCBParticle(GetParticle(i)->GetTypeID())->GetYCoordinate();
    long int z = GetCBParticle(GetParticle(i)->GetTypeID())->GetZCoordinate();
    
    //Determine particle global index from coordinates
    long int CB_index = ((Ybound+1)*(Zbound+1)*x) + ((Ybound+1)*z) + y;

    //Create temporary integers for interparticle distance calculations. Dpi = diameter particle i
    //Dpj = diameter particle j, iPSoftness = allowable penetration particle i, jPSoftness =
    //allowable penetration of particle j
    int iPSoftness, jPSoftness, dpi, dpj;
    
    //Temporary double for storing results of distance calculation
    double dist;
    
    //Get the proper index for the map of the particle
    int which_set = Get_Max_CB_Map_Index(i);
    long int which_index;
    long int max_index = Potential.size();

    //Loop through the indices of the CB_Potential map. Particles at these indices would create
    //neighboring relationships to the current particle.
    for (int j = 0; j < CB_Potential_Maps_Indices[which_set].size(); j++)
    {
        //Determine global translation of mapped index based off the reference particle index
        which_index = CB_index + CB_Potential_Maps_Indices[which_set][j];

        //Check the bounds of the potential map index. If not within bounds of RVE, skip.
        if (x + CB_Potential_Maps_X[which_set][j] > Xbound || x + CB_Potential_Maps_X[which_set][j] < 0) {continue;}
        if (y + CB_Potential_Maps_Y[which_set][j] > Ybound || y + CB_Potential_Maps_Y[which_set][j] < 0) {continue;}
        if (z + CB_Potential_Maps_Z[which_set][j] > Zbound || z + CB_Potential_Maps_Z[which_set][j] < 0) {continue;}
        if (which_index > max_index) {continue;}
        
        //Once arrived at this point, the index deemed within the RVE. Check the existence of a particle at
        //that index via the isNull function and All_Indices. The variable p_ID is used to store the
        //ID# of the particle at that index, should there be one.
        long int p_ID;
        if(isNull(All_Indices[x+CB_Potential_Maps_X[which_set][j]], y+CB_Potential_Maps_Y[which_set][j], z+CB_Potential_Maps_Z[which_set][j]) == true)
        {
            //If isNull == true, then there is no particle at the index. Onto the next one!
            continue;
        }
        //If isNull == false, there is a particle at that index! The ID of the particle at that index is
        //stored in All_Indices and is called by the coeffRef command, and stored in p_ID
        else
        {
            p_ID = All_Indices[x+CB_Potential_Maps_X[which_set][j]].coeffRef(y+CB_Potential_Maps_Y[which_set][j], z+CB_Potential_Maps_Z[which_set][j]);
        }
        
        //Define the characteristics of the particles using the IDs and their object functions.
        int Particle_i_Type = GetParticle(i)->GetType();
        int Particle_j_Type = GetParticle(p_ID)->GetType();
        if (Particle_i_Type <= NumCBFillers)
        {
            iPSoftness = GetCBMatType(GetCBParticle(GetParticle(i)->GetTypeID())->GetMatType())->GetPenetrationAllowance()*mult;
            dpi = GetCBParticle(GetParticle(i)->GetTypeID())->GetDiameter()*mult;
        }
        if (Particle_j_Type <= NumCBFillers)
        {
            jPSoftness = GetCBMatType(GetCBParticle(GetParticle(p_ID)->GetTypeID())->GetMatType())->GetPenetrationAllowance()*mult;
            dpj = GetCBParticle(GetParticle(p_ID)->GetTypeID())->GetDiameter()*mult;
        }
        
        //Determine the most restrictive penetration allowance
        double PS;
        if (iPSoftness < jPSoftness)
        {
            PS = iPSoftness;
        }
        else
        {
            PS = jPSoftness;
        }
        
        //Call the function to calculate the distance between particle i and particle j
        dist = GetCBParticle(GetParticle(i)->GetTypeID())->FindDistanceToNeighbor(GetCBParticle(GetParticle(p_ID)->GetTypeID()));

        //Check distance w.r.t the particle sizes and tunneling allowance
        if (dist < ((dpi+dpj)/2.0) + (Td) || std::fabs(dist - ((dpi+dpj)/2.0) - (Td)) < 0.000001)
        {
            //Checking interference allowance of most restrictive particle
            if (dist > (((dpi+dpj)/2.0)-(mult*PS)) || std::fabs(dist-(((dpi+dpj)/2.0)+(mult*PS))) < 0.000001)
            {
                //Particles are close enough to be neighbors! Add neighbor info to particle i's
                //data containers via the object function call.
                GetCBParticle(GetParticle(i)->GetTypeID())->AddNeighbor(p_ID, dist);
            }
        }
    }
}

bool RVEdata::isNull(const Eigen::SparseMatrix<double, Eigen::ColMajor>& mat, int row, int col)
{
    //This function checks the sparse matrix (All_Indices[x]) to see if a particle exists at the given index
    //(row,col). This works by using an InnerIterator. The way this works is that the pull out a column
    //from the sparse matrix (col), and we check the nonzero entries of that column. The nonzero entries
    //are held in a list that also contain their row assignments which are output by the it.row() command.
    //If the it.row() == row is true, it means there is a nonzero entry in the (row,col) position of the
    //sparse matrix. This is complicated because of how sparse matrices are stored for data saving.
    for (Eigen::SparseMatrix<double, Eigen::ColMajor>::InnerIterator it(mat, col); it; ++it)
    {
        if (it.row() == row) {return false;}
    }
    return true;
}

Particles* RVEdata::GetParticle(long int i)
{
    return &particle_data[i];
}

CBparticle* RVEdata::GetCBParticle(long int num)
{
    return &CB_particles[num];
}

CNTparticle* RVEdata::GetCNTParticle(long int num)
{
    return &CNT_particles[num];
}

CBMaterialData* RVEdata::GetCBMatType(int i)
{
    return &CB_data[i];
}

PolymerData* RVEdata::GetPolymerData()
{
    return &p_data;
}

long int RVEdata::GetXBoundaryLimit()
{
    return Xbound;
}

bool RVEdata::SolveForStrainConductivity(float strain_elong, std::ofstream &cond_out)
{
    float eps1 = 1 + strain_elong;
    float Poissons = p_data.GetPoissonsRatio();
    float eps2, eps3;
    if (Poissons != 0)
    {
        eps2 = 1 - (strain_elong*Poissons);
        eps3 = 1 - (strain_elong*Poissons);
    }
    else
    {
        eps2 = 1;
        eps3 = 1;
    }
    
    //Vectors passed to the find network algorithm
    long int N = particle_data.size();
    
    std::deque<std::mutex> PosLocks(N);
    std::deque<std::mutex> GndLocks(N);
    
    posbank.resize(N, std::vector<bool> (2));
    gndbank.resize(N, std::vector<bool> (2));
    network.resize(N);
    
    //Initialize vector lock objects
    for (long int i = 0; i<N; i++)
    {
        posbank[i][0] = false;
        gndbank[i][0] = false;
        posbank[i][1] = false;
        gndbank[i][1] = false;
    }
    
    //Find the networked particles
    NetExists = FindStrainNetwork(N, PosLocks, GndLocks, eps1);
    
    if (NetExists == false)
    {
        //std::cout << "No Net" << std::endl;
        RVEconductivity = 0;
        RVEresistance = 0;
        cond_out << strain_elong << "," << RVEresistance << "," << RVEconductivity << "," << std::endl;
        return false;
    }
    //std::cout << "Net Exists" << std::endl;
    
    //If arrived at this point, solve for conducitiviy of network particles
    SolveForNodalVoltages();
    
    RVEresistance = VIN/sumCurrent;
    sumCurrent = 0;
    
    RVEconductivity = (Xbound*d*eps1)/(Ybound*Zbound*d*d*eps2*eps3*RVEresistance);
    //std::cout << "Resistance = " << RVEresistance << ", strain=" << strain_elong << std::endl;
    cond_out << strain_elong << "," << RVEresistance << "," << RVEconductivity << "," << std::endl;
    return true;
}

bool RVEdata::SolveForConductivity()
{
    //This function determines the conductivity of the RVE.
    
    //Vectors passed to the network finding algorithm
    //N is the total number of particles in the system
    long int N = particle_data.size();
    
    //These are deques of mutexes, which can conceptualized as arrays of padlocks.
    std::deque<std::mutex> PosLocks(N);
    std::deque<std::mutex> GndLocks(N);
    
    //These vectors are used to determine which particles (if any) are part of a network
    //creating an electrical connection between x- and x+ faces of the RVE.
    posbank.resize(N, std::vector<bool> (2));
    gndbank.resize(N, std::vector<bool> (2));
    
    //This boolean array stores info regarding which particles are part of the network and
    //which particles are not
    network.resize(N);
    
    //Initialize boolean vectors to all false
    for (long int i = 0; i<N; i++)
    {
        posbank[i][0] = false;
        gndbank[i][0] = false;
        posbank[i][1] = false;
        gndbank[i][1] = false;
    }
    
    //Call the network finding function which returns a boolean true/false
    NetExists = FindNetwork(N, PosLocks, GndLocks);
    
    //If NetExists == false, then the RVE configuration is not conductive according to the
    //theoretical laws governing the physics of the system.
    if (NetExists == false)
    {
        //If no network exists, the conductivity is zero and the resistance is infinite
        RVEconductivity = 0;
        RVEresistance = 0;
        return false;
    }
    
    //If arrived at this point, a conductive network was found to exist. Solve for
    //nodal voltages of networked particles.
    SolveForNodalVoltages();

    //Determine the effective resistance of the RVE from the summation of the incoming current.
    RVEresistance = VIN/sumCurrent;
    RVEconductivity = (Xbound*d)/(Ybound*Zbound*d*d*RVEresistance);
    sumCurrent = 0;
    return true;
}

bool RVEdata::FindNetwork(long int N, std::deque<std::mutex> &PosLocks, std::deque<std::mutex> &GndLocks)
{
    //Loop through all the particles to determine which particles are connected to the
    //x+ and x- electrodes. Store that data in the posbank and gndbank containers.
    for (long int i = 0; i<particle_data.size(); i++)
    {
        if (particle_data[i].GetType() < NumCBFillers)
        {
            //Call IsPositive() and IsNegative() to put true/false into the pos/gnd-banks
            posbank[i][0] = CB_particles[particle_data[i].GetTypeID()].IsPositive();
            gndbank[i][0] = CB_particles[particle_data[i].GetTypeID()].IsNegative();
        }
        else
        {
            //It's a CNT (Not yet developed)
        }
    }
    
    //Store number of processesors available for multi-threading
    int NumProcessors = std::thread::hardware_concurrency();

    //Create vector of futures for searching algorithms
    std::vector<std::future<void> > BranchSearchSplit;
    
    //Half of available processes do positive search, half do negative search
    BranchSearchSplit.push_back(std::async(std::launch::async, &RVEdata::PositiveBranch, this, NumProcessors/2, std::ref(PosLocks)));
    BranchSearchSplit.push_back(std::async(std::launch::async, &RVEdata::NegativeBranch, this, NumProcessors/2, std::ref(GndLocks)));
    
    //Once the processes have been tasked with finding the network, wait for them to finish using .wait()
    BranchSearchSplit[0].wait();
    BranchSearchSplit[1].wait();
    
    //Loop through the network[] container to count the number of networked particles
    int NumNetwork = 0;
    for (unsigned long int i = 0; i<N; i++)
    {
        if (posbank[i][1] == true && gndbank[i][1] == true)
        {
            network[i] = 1;
            NumNetwork += 1;
        }
        else
        {
            network[i] = 0;
        }
    }
    
    //If numnetwork > 0, then a conductive network exists within the RVE
    if (NumNetwork > 0)
    {
        return(true);
    }
    else
    {
        return(false);
    }
}

bool RVEdata::FindStrainNetwork(long int N, std::deque<std::mutex> &PosLocks, std::deque<std::mutex> &GndLocks, float eps1)
{
    //Fill initial posbank and gndbank first rows
    for (long int i = 0; i<particle_data.size(); i++)
    {
        if (particle_data[i].GetType() < NumCBFillers)
        {
            //It's a cb particle
            if (CB_particles[particle_data[i].GetTypeID()].Strain_IsPositive(eps1,Xbound,Td) == true)
            {
                posbank[i][0] = true;
            }
            else
            {
                posbank[i][0] = false;
                particle_data[i].SetPosTerminalResistance(0);
            }
            if (CB_particles[particle_data[i].GetTypeID()].Strain_IsNegative(eps1,Xbound,Td) == true)
            {
                gndbank[i][0] = true;
            }
            else
            {
                gndbank[i][0] = false;
            }
        }
        else
        {
            //It's a cnt particle
        }
    }
    
    //Count num of processesors available
    int NumProcessors = std::thread::hardware_concurrency();
    
    //Half of available processors do positive search, half do negative search
    std::vector<std::future<void> > BranchSearchSplit;
    
    BranchSearchSplit.push_back(std::async(std::launch::async, &RVEdata::PositiveBranch, this, NumProcessors/2, std::ref(PosLocks)));
    BranchSearchSplit.push_back(std::async(std::launch::async, &RVEdata::NegativeBranch, this, NumProcessors/2, std::ref(GndLocks)));
    BranchSearchSplit[0].wait();
    BranchSearchSplit[1].wait();
    
    //Variable for storing the count of how many particles are networked from pos to gnd
    int NumNetwork = 0;
    
    //Loop through each index. If posbank and gndbank at index i are true, then 1) a network
    //exists in the RVE and 2) that particle is particle of the network.
    for (unsigned long int i = 0; i<N; i++)
    {
        if (posbank[i][1] == true && gndbank[i][1] == true)
        {
            //Set the network[i] to true to signify that particle i is part of the conductive network
            network[i] = 1;
            //increment the counter
            NumNetwork += 1;
        }
        else
        {
            //particle i is not in the network, so signify that
            network[i] = 0;
        }
    }
    
    //If the counter is greater than zero, a net exists and it needs to be analyzed for conductivity
    //return true or false
    if (NumNetwork > 0)
    {
        return(true);
    }
    else
    {
        return(false);
    }
}

void RVEdata::PositiveBranch(int NumProcessors, std::deque<std::mutex> &PosLocks)
{
    //initializing variables that help identify when all pos network has been found
    int NumPos2 = 0;
    int NumPos = 1;
    
    // This while loop is dependent on the two summing integers (NumPos2 and NumPos). In each iteration
    // the code will find positive network particles identified by a 1 in the first row of the
    // posbank matrix. If the particle has a "0" in the second row and a 1 in the first row,
    // this signals that the particle has not yet been processed. Processing involves obtaining a list of
    // the particles neighbors, and changing each corresponding 1st row of posbank[neighbor]
    // to 1. The # of 1's in posbank are summed before the loop (NumPos) and after the loop (NumPos2).
    // if NumPos = NumPos2, then no new positively connected particles were found in the iteration.
    // This means that all positively connected particles have been identified. This process is
    // parallelized for rapidity. For parallelization, mutexes are used to maitain data integrity.
    // A mutex makes it so that only one process can change posbank at a time. This maintains that
    // no process accidentally overwrites the other.
    
    //If NumPos == NumPos2, then we have finished the positive search
    while (NumPos != NumPos2)
    {
        // Finding the total number of particles in the positive network at the loop start
        NumPos = 0;
        for (unsigned long int w = 0; w<particle_data.size(); w++)
        {
            //Sum the NumPos variable
            if (posbank[w][1] == true)
            {
                NumPos += 1;
            }
        }
        
        //Split the task of obtaining neighbor lists and filling posbank to seperate processes
        //using multi-threading (futures)
        std::vector<std::future<void> > SearchersPos;
        
        //Add processes (futures) until the total number of desired processes is met
        //Function variables include PosLocks.
        for (int i = 0; i<NumProcessors; i++)
        {
            SearchersPos.push_back(std::async(std::launch::async, &RVEdata::PositiveSearch, this, std::ref(PosLocks)));
        }
        
        //Wait for the threads to finish their work
        for (int i = 0; i<NumProcessors; i++)
        {
            SearchersPos[i].wait();
        }
        
        // Finding the total number of particles in the pos network at the end of the loop
        NumPos2 = 0;
        for (unsigned long int w = 0; w<particle_data.size(); w++)
        {
            if (posbank[w][1] == true)
            {
                NumPos2 += 1;
            }
        }
    }
}

void RVEdata::PositiveSearch(std::deque<std::mutex> &PosLocks)
{
    //Algorithm that obtains neighbors from particles that need to be searched and have
    //posbank placeholders updated at indices corresponding to neighbor IDs. This algorithm
    //can be thought of as Leap Frog. The proceesors are all trying to access the PosLock
    //mutexes. The PosLock container is an array (length equal to length of posbank) containing
    //mutexes corresponding to each index in posbank. The processes all loop through the same
    //list of mutexes, trying to lock one at a time to work on. Only ONE process can lock a
    //mutex, and if this happens, the mutex will not allow another process to access it
    //(returing PosLock[i].try_lock() = False). The process then tries the next lock (index i+1).
    //This happens until all processes move through the list and exit the subroutine. At which
    //time the PostiveBranch function performs the iterations final NumPos count.
    
    //Neighbors vector placeholder
    std::vector<long int> neighbors;
    //Temp integer - number of neighbors to be processed
    unsigned long int NumNeigh = 0;
    
    //Loop through all indices in PosLocks (i.e. length of particle_data & posbank)
    for (unsigned long int i = 0; i<particle_data.size(); i++)
    {
        //If try_lock is successful, this thread has ownership of the index i search
        if (PosLocks[i].try_lock() == true)
        {
            //If the [i][0] container is true and [i][1] is false, this particle needs its neighbors
            //processed for adding them to the positive network (posbank)
            if (posbank[i][0] == true && posbank[i][1] == false)
            {
                //Retrieve particle i's neighbors and set NumNeigh accordingly
                neighbors = GetNeighbors(i);
                NumNeigh = neighbors.size();
                
                //If the particle has neighbors, process them
                if (NumNeigh != 0)
                {
                    //Loop through particle i's neighbors list
                    for (unsigned int b = 0; b<NumNeigh; b++)
                    {
                        //Boolean and integers for determining when neighbor has been processed
                        bool Success = false;
                        int FailCount = 0;
                        
                        //Keep trying to process neighbor until FailCount gets too loarge
                        while (Success == false)
                        {
                            //If try_lock succeeds, add 1 to posbank[neighbors[b][0]. If fails, loop
                            // again and wait for successful lock attempt (max of 5 times)
                            if (PosLocks[neighbors[b]].try_lock() == true)
                            {
                                posbank[neighbors[b]][0] = true;
                                PosLocks[neighbors[b]].unlock();
                                
                                //Once posbank updated, set to true to end while loop
                                Success = true;
                            }
                            else
                            {
                                //If lock failed, increment failcount
                                FailCount += 1;
                            }
                            
                            //If try_lock fails 5 times, abort this attempt and DONT mark this partilce
                            //as finished (don't set posbank[i][1] to true).
                            if (FailCount > 5)
                            {
                                //Unlock this PosLock
                                PosLocks[i].unlock();
                                //Skip to end of loop (TryLaterNeg)
                                goto TryLaterNeg;
                            }
                        }
                    }
                }
                //Particle has been successfully processed. Add 1 to posbank[i][1] for summing.
                posbank[i][1] = 1;
            }
            PosLocks[i].unlock();
        TryLaterNeg:
            continue;
        }
        //If lock failed, this particle is being processed by another process.
        else
        {
            continue;
        }
    }
}

void RVEdata::NegativeBranch(int NumProcessors, std::deque<std::mutex> &GndLocks)
{
    // Finding the total number of particles direclty connected to positive electrode
    int NumGnd = 1;
    int NumGnd2 = 0;
    
    // This while loop is dependent on the two summing integers (NumGnd2 and NumGnd). In each iteration
    // the code will find ground network particles identified by a 1 in the first row of the
    // gndbank matrix. If the particle has a "0" in the second row and a 1 in the first row,
    // this signals that the particle has not yet been processed. Processing involves obtaining a list of
    // the particles neighbors, and changing each corresponding 1st row of gndbank[neighbor]
    // to 1. The # of 1's in gndbank are summed before the loop (NumGnd) and after the loop (NumGnd2).
    // if NumGnd = NumGnd2, then no new ground connected particles were found in the iteration.
    // This means that all ground connected particles have been identified. This process is
    // parallelized for rapidity. For parallelization, mutexes are used to maitain data integrity.
    // A mutex makes it so that only one process can change gndbank at a time. This maintains that
    // no process accidentally overwrites the other.

    //If NumGnd == NumGnd2, then we have finished the ground search
    while (NumGnd != NumGnd2)
    {
        // Finding the total number of particles in the ground network at the loop start
        NumGnd = 0;
        for (unsigned long int w = 0; w<particle_data.size(); w++)
        {
            //Sum the NumGnd variable at loop start
            if (gndbank[w][1] == true)
            {
                NumGnd += 1;
            }
        }
        
        //Split the task of obtaining neighbor lists and filling posbank to seperate processes
        //using multi-threading (futures)
        std::vector<std::future<void> > SearchersNeg;
        
        //Add processes (futures) until the total number of desired processes is met
        //Function variables include GndLocks.
        for (int i = 0; i<NumProcessors; i++)
        {
            SearchersNeg.push_back(std::async(std::launch::async, &RVEdata::NegativeSearch, this, std::ref(GndLocks)));
        }
        
        //Wait for the threads to finish their work
        for (int i = 0; i<NumProcessors; i++)
        {
            SearchersNeg[i].wait();
        }
        
        // Finding the total number of particles in the gnd network at the end of the loop
        NumGnd2 = 0;
        for (unsigned long int w = 0; w<particle_data.size(); w++)
        {
            if (gndbank[w][1] == true)
            {
                NumGnd2 += 1;
            }
        }
    }
}

void RVEdata::NegativeSearch(std::deque<std::mutex> &GndLocks)
{
    //Algorithm that obtains neighbors from particles that need to be searched and have
    //gndbank placeholders updated at indices corresponding to neighbor IDs. This algorithm
    //can be thought of as Leap Frog. The proceesors are all trying to access the GndLock
    //mutexes. The GndLock container is an array (length equal to length of gndbank) containing
    //mutexes corresponding to each index in gndbank. The processes all loop through the same
    //list of mutexes, trying to lock one at a time to work on. Only ONE process can lock a
    //mutex, and if this happens, the mutex will not allow another process to access it
    //(returing GndLock[i].try_lock() = False). The process then tries the next lock (index i+1).
    //This happens until all processes move through the list and exit the subroutine. At which
    //time the NegativeBranch function performs the iterations final NumGnd count.
    
    //Neighbors vector placeholder
    std::vector<long int> neighbors;
    //Temp integer - number of neighbors to be processed
    unsigned long int NumNeigh = 0;

    //Loop through all indices in GndLocks (i.e. length of particle_data & gndbank)
    for (unsigned long int i = 0; i<particle_data.size(); i++)
    {
        //If try_lock is successful, this thread has ownership of the index i search
        if (GndLocks[i].try_lock() == true)
        {
            //If the [i][0] container is true and [i][1] is false, this particle needs its neighbors
            //processed for adding them to the ground network (gndbank)
            if (gndbank[i][0] == true && gndbank[i][1] == false)
            {
                //Retrieve particle i's neighbors and set NumNeigh accordingly
                neighbors = GetNeighbors(i);
                NumNeigh = neighbors.size();
                if (NumNeigh != 0)
                {
                    //Loop through particle i's neighbors list
                    for (unsigned int b = 0; b<NumNeigh; b++)
                    {
                        //Boolean and integers for determining when neighbor has been processed
                        bool Success = false;
                        int FailCount = 0;
                        
                        //Keep trying to process neighbor until FailCount gets too loarge
                        while (Success == false)
                        {
                            //If try_lock succeeds, add 1 to gndbank[neighbors[b][0]. If fails, loop
                            // again and wait for successful lock attempt (max of 5 times)
                            if (GndLocks[neighbors[b]].try_lock() == true)
                            {
                                gndbank[neighbors[b]][0] = true;
                                GndLocks[neighbors[b]].unlock();
                                
                                //Once gndbank updated, set to true to end while loop
                                Success = true;
                            }
                            else
                            {
                                //If lock failed, increment failcount
                                FailCount += 1;
                            }
                            
                            //If try_lock fails 5 times, abort this attempt and DONT mark this partilce
                            //as finished (don't set gndbank[i][1] to true).
                            if (FailCount > 5)
                            {
                                //Unlock this GndLock
                                GndLocks[i].unlock();
                                //Skip to end of loop (TryLaterNeg)
                                goto TryLaterNeg;
                            }
                        }
                    }
                }
                //Particle has been successfully processed. Add 1 to posbank[i][1] for summing.
                gndbank[i][1] = 1;
            }
            GndLocks[i].unlock();
        TryLaterNeg:
            //Continue to next iteration of the loop.
            continue;
        }
        //If lock failed, this particle is being processed by another process.
        else
        {
            continue;
        }
    }
}

void RVEdata::OutputResults(std::ofstream &fout)
{
    fout << RVEresistance << "," << RVEconductivity << "," << std::endl;
}

std::vector<long int> &RVEdata::GetNeighbors(long int i)
{
    //Return vector of neighbors of particle i via the particle object functino call
    if (particle_data[i].GetType() < NumCBFillers)
    {
        return CB_particles[particle_data[i].GetTypeID()].GetNeighborsVector();
    }
    else
    {
        //If we are here, something is broken because use of this option hasn't been coded yet.
        std::cout << "ERROR: CNT particles don't exist yet" << std::endl;
        exit(1);
    }
}

std::vector<double> &RVEdata::GetNeighborsDist(long int i)
{
    //Return vector of distances between neighbors of particle i via the particle object function call
    if (particle_data[i].GetType() < NumCBFillers)
    {
        return CB_particles[particle_data[i].GetTypeID()].GetNeighborsDistVector();
    }
    else
    {
        //If we are here, something is broken because use of this option hasn't been coded yet.
        std::cout << "ERROR: CNT particles don't exist yet" << std::endl;
        exit(1);
    }
}

void RVEdata::SolveForNodalVoltages()
{
    //Function used to solve for the nodal voltages of the particles in the RVE. This is done
    //by solving the random resistor network according to KCL and Ohms Law. These two equations
    //can be combined to form a linear algebra problem that can be solved for nodal voltages.
    //The building and solving of this system of equations is parrelized for efficiency sake.
    
    //Define the potential difference between the positive and negative electrode faces.
    int VIN = 5;
    
    //Count number of networked particles and assign them row indices
    std::vector<long int> Indices;
    std::vector<long int> NeighborIndices;
    long int SumNet = 0;
    for (long int i = 0; i < network.size(); i++)
    {
        //If particle is in the network, add the particle's global ID to the Indices vector
        //and increment the SumNet counter variable. The NeighborIndices vector stores the
        //row # of the particle in the conductive network solving system of equations.
        if (network[i] == true)
        {
            Indices.push_back(i);
            NeighborIndices.push_back(SumNet);
            SumNet += 1;
        }
        //If not in the network, don't increment the counter and add a -1 to the NeighborIndices vector
        //signifying the particle is not in the network.
        else
        {
            NeighborIndices.push_back(-1);
        }
    }
    
    //Define contact resistance between carbon allotropes in ohms
    double Rc = 15000;
    
    //Define the sparse matrix (g) used in solving the linear system of equations
    //The conductivity matrix is mostly empty, with a few row/columns containing
    //double precision values. For this reason, we only initialize 10 values per row,
    //equation to 10 neighbors per particle which is an overestimate that helps speed
    //up the algorithm by eliminating the need to initialize more space for the matrix
    Eigen::SparseMatrix<double, Eigen::ColMajor> g (SumNet, SumNet);
    g.reserve(10);
    
    //Initialize the incoming current vector (curr)
    Eigen::VectorXd curr = Eigen::VectorXd::Zero(SumNet);
    
    //Count num of processesors available for parallelizing the system of equations builder
    int NumProcessors = std::thread::hardware_concurrency();
    
    //For filling the current vector (curr) and conductivity matrix (g), we give each process
    //an equal number of particles to process.
    long int NumP = SumNet / NumProcessors;
    long int Left = SumNet % NumProcessors;
    
    //Create container of threads that return triplets. The triplets contain info regarding which
    //values need to be added to which rows/cols of the conductivity matrix.
    //The values stored by these triplets are (value, row, col). These triplets are eventually
    //combined to create a 2-D sparse matrix for solving.
    std::vector<std::future<std::vector<Eigen::Triplet<double> > > > Waiters;
    typedef Eigen::Triplet<double> T;
    
    //The vector of triplets prepares the triplets to be combined into a 2D sparse matrix
    std::vector<T> GtripletList;
    
    //The ValuesCurr container stores the temporary info regarding positively connected particles
    //and their conductance to the terminal face.
    std::vector<double> ValuesCurr;
    ValuesCurr.resize(SumNet);
    
    //Start a clock for estimating time to finish equation building
    auto FillStart = std::chrono::high_resolution_clock::now();
    
    //Create temporary integers for assigning index ranges to each process
    long int start = 0;
    long int finish;
    
    //Loop to initialize the threads and assign them a range of indices to create and return
    //lists of triplets (to fill g and curr) for.
    for (int i = 0; i<NumProcessors; i++)
    {
        //If on the last available process, set the end of the range to the last index
        if (i == NumProcessors - 1)
        {
            finish = SumNet;
        }
        //If not the last process, set the range: start -> start+NumP
        else
        {
            finish = start + NumP;
        }
        //Initialize the process and command it to perform the FillCurrAndG function for the range
        Waiters.push_back(std::async(std::launch::async, &RVEdata::FillCurrAndG, this, std::ref(ValuesCurr), std::ref(Indices), std::ref(NeighborIndices), Rc, VIN, start, finish));
        
        //Increment start by NumP and continue to the next iteration.
        start += NumP;
    }
    
    //Temporary triplet list for acessing vectors returned by threads
    std::vector<Eigen::Triplet<double> > Gtemp;
    
    //Fill the triplet list created by the threads as they are returned
    for (int i = 0; i<Waiters.size(); i++)
    {
        //Wait until process i is done
        Waiters[i].wait();
        
        //Retrieve the temp triplet list from the finished process
        Gtemp = Waiters[i].get();
        
        //Insert temp triplet list into accumulated triplet list
        GtripletList.insert(GtripletList.end(), Gtemp.begin(), Gtemp.end());
        
        //Clear temp triplet list for next iteration
        Gtemp.clear();
    }
    
    //Fill curr Eigen object using function argument vector
    for (long int i = 0; i<SumNet; i++)
    {
        //If a nonzero value exists at index i, add that value to the corresponding
        //row in the Eigen vector
        if (ValuesCurr[i] > 0)
        {
            curr(i) = ValuesCurr[i];
        }
    }
    
    //Fill the cond matrix using the accumulated triplet list created by the thread outputs
    g.setFromTriplets(GtripletList.begin(), GtripletList.end());

    //Clock entry for timing the simulation
    auto FillFinish = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> FilledElapsed = FillFinish - FillStart;
    
    //Perform linear algebra to obtain nodal voltages and output info for debugging
    //Finalize the conductivity matrix.
    g.finalize();
    
    //Define the Eigen sparse matrix solver. For this problem, SimplicialLDLT was found
    //to be the fastest solver.
    Eigen::SimplicialLDLT <Eigen::SparseMatrix<double, Eigen::ColMajor> > solver;
    
    //Compress the g matrix
    g.makeCompressed();
    
    //Analyze the pattern of g via the solver
    solver.analyzePattern(g);
    solver.compute(g);
    
    //Create the nodal voltage vector to output the solver results to
    Eigen::VectorXd V = Eigen::VectorXd::Zero(SumNet,1);
    
    //Factorize g via the solver
    solver.factorize(g);

    //Check to make sure factorization was successful
    if (solver.info() != 0)
    {
        std::cout << std::endl << "Matrix Factorization Failed!" << std::endl;//<< solver.lastErrorMessage() << std::endl;
        exit (1);
    }
    
    //Once factorization validated, solve the system of equations for the nodal voltages
    V = solver.solve(curr);
    
    auto Solved = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> SolvedFinal = Solved - FillFinish;
    
    //Fill Voltage vector in RVEdata class with nodal voltages found
    //Resize the Nodal_Voltages vector accordingly
    Nodal_Voltages.resize(particle_data.size());
    
    //Initialize counter variable
    int ph = 0;
    
    //Loop through each particle in the RVE
    for (long int i = 0; i < particle_data.size(); i++)
    {
        //if particle i is in not in the network, the nodal voltage is set to zero and the next
        //iteration of the loop is performed keeping the counter variable the same
        if (network[i] == false)
        {
            Nodal_Voltages[i] = 0;
            continue;
        }
        
        //If arrived here, the particle IS in the network and has a nodal voltage associated with the
        //sovler output vector V. Set Nodal_Voltages[i] to V[ph] and increment ph
        Nodal_Voltages[i] = V.coeffRef(ph);
        ph += 1;
        
        //If the nodal voltage is greater than VIN, then we have problems and something is broken.
        //That is check via this if statement.
        if (Nodal_Voltages[i]-VIN > 0.001)
        {
            std::cout << "i: " << i << " V: " << Nodal_Voltages[i] << std::endl;
        }
    }
    
    //Sum the current flowing into the positively connected particles. This is necessary to calculate
    //the effective resistance of the RVE.
    
    //Loop through each particle in the network
    for (long int i = 0; i < SumNet; i++)
    {
        //If the Positive terminal resistance is not zero (each particle is initialized to have
        //this variable set to zero), then it means it was changed during FillCurrAndG. It is
        //positively connected.
        if (particle_data[Indices[i]].GetPosTerminalResistance() != 0)
        {
            //Add the current flowing in through this particle to the running sum variable "sumCurrent"
            sumCurrent += (VIN - Nodal_Voltages[Indices[i]])/particle_data[Indices[i]].GetPosTerminalResistance();
        }
    }
}

std::vector<Eigen::Triplet<double> > RVEdata::FillCurrAndG(std::vector<double> &ValuesCurr, std::vector<long int> &Indices, std::vector<long int> &NeighborIndices, double Rc, int VIN, long int start, long int finish)
{
    //Function that is threaded to fill temporary current and conductivity entries in triplet form.
    //The triplets are used to build matrices required to solve for nodal voltages via KCL and Ohms Law.
    
    //Define temporary storage containers for particle neighbor information
    std::vector<long int> neighbors;
    std::vector<double> neighborsDist;
    
    //Define the temporary triplet list
    std::vector<Eigen::Triplet<double> > G;
    
    //Define precision variables for calcuating conductivity triplet entries
    double TunnelingThresh;
    double TunnelingResistance;
    double ValuesG;
    
    //Loop from the first particle index (start) to the last in the range (finish) filling the
    //triplet list as we go.
    for (long int i = start; i<finish; i++)
    {        
        //Gather neighbor lists (neighbor indices and distancesto neighbors) from particle
        //index i object. Since the particle's network ID is different than its global ID,
        //use the Indices vector to get the proper particle object
        neighbors = GetNeighbors(Indices[i]);
        neighborsDist = GetNeighborsDist(Indices[i]);
        
        //Loop through the neighbors list to create the triplet entry for that particle pair
        for (int j = 0; j < neighbors.size(); j++)
        {
            //Calculate the tunneling threhsold between the two particles via the function call.
            TunnelingThresh = CalcTunnelingThreshold(Indices[i],neighbors[j]);
            
            //If the distance between particle i and j is less than the tunn threshold, particles
            //are in contact.
            if (neighborsDist[j] < TunnelingThresh || std::abs(neighborsDist[j] - TunnelingThresh) < 0.0001)
            {
                //Add the negative inverse of the assumed contact resistance to the triplet list for
                //the matrix position (i,neighbors[j])
                ValuesG = -1.0/Rc;
                G.push_back(Eigen::Triplet<double>(i,NeighborIndices[neighbors[j]],ValuesG));
                
                //Add the inverse of the resistance to the triplet list at the (i,i) matrix position
                ValuesG = 1.0/Rc;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
            //If the distance between particle i and j is greater than the tunn threshold, particles
            //are conducting via tunneling
            else
            {
                //Define the tunneling area between the particles via the function call
                long double At = FindTunnelingArea(Indices[i],neighbors[j]);
                
                //Define the tunneling resistance between the pair via the function call
                TunnelingResistance = CalcTunnelingResistance(neighborsDist[j], TunnelingThresh, d, At);
                
                //If tunneling resistance is less than Rc, set the resistance between the pair to
                //be equivalent to a contact resistance. This is effectively a piecewise fit.
                if (TunnelingResistance < Rc)
                {
                    TunnelingResistance = Rc;
                }
                
                //Add to the triplet list. For index (i,neighbors[j]), add the negative inverse
                //of the tunneling resistance
                ValuesG = -1.0/TunnelingResistance;
                G.push_back(Eigen::Triplet<double>(i,NeighborIndices[neighbors[j]],ValuesG));
                
                //Add to the triplet list. For index (i,i), add the  inverse
                //of the tunneling resistance
                ValuesG = 1.0/TunnelingResistance;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
        }
        
        //Check particle i's relation to positive and negative terminals via the CheckPosNeg function
        if (CheckPosNeg(Indices[i],false) == true)
        {
            //Particle i is connected to the positive terminal and requires entries to both the
            //g anc curr matrices
            
            //Find distance to positive terminal via the function call
            double dist = FindDistanceToTerminal(false,Indices[i]);
            
            //Calculate the tunneling threshold of the particle-terminal pair via function call
            TunnelingThresh = CalcTunnelingThresholdToTerminal(Indices[i]);
            
            //If the distance between the terminal-particle is less than the threshold, the pair
            //are in direct contact
            if (dist < TunnelingThresh || std::abs(dist - TunnelingThresh) < 0.0001)
            {
                //Particles are in contact. Save the resistance between the particle and terminal
                //in the particle object for later manipulation
                particle_data[Indices[i]].SetPosTerminalResistance(Rc);
                
                //Add entry to the current matrix equal to VIN/Rc at index i
                ValuesCurr[i] = (VIN/Rc);
                
                //Add entry to the conductivity matrix at index (i,i) of 1/Rc
                ValuesG = 1.0/Rc;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
            //Particle-terminal are conducting via tunneling
            else
            {
                //Calculate the tunneling area between particle-terminal via functino call
                long double At = FindTunnelingArea(Indices[i],-1);
                
                //Calcaute the tunneling resistance between particle-termina via function call
                TunnelingResistance = CalcTunnelingResistance(dist, TunnelingThresh, d, At);
                
                //If tunneling resistance is less than Rc, set the resistance between the pair to
                //be equivalent to a contact resistance. This is effectively a piecewise fit.
                if (TunnelingResistance < Rc)
                {
                    TunnelingResistance = Rc;
                }
                
                //Save the resistance between the particle and terminal in the particle
                //object for later manipulation
                particle_data[Indices[i]].SetPosTerminalResistance(TunnelingResistance);
                
                //Add entry to the current matrix equal to VIN/TunnelingResistance at index i
                ValuesCurr[i] = (VIN/TunnelingResistance);
                
                //Add to the triplet list. For index (i,i), add the inverse
                //of the tunneling resistance
                ValuesG = 1.0/TunnelingResistance;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
        }
        if (CheckPosNeg(Indices[i],true) == true)
        {
            //Particle i is connected to the ground terminal
            
            //Find distance to ground terminal via the function call
            double dist = FindDistanceToTerminal(true,Indices[i]);
            
            //Calculate the tunneling threshold of the particle-terminal pair via function call
            TunnelingThresh = CalcTunnelingThresholdToTerminal(Indices[i]);
            
            //If the distance between the terminal-particle is less than the threshold, the pair
            //are in direct contact
            if (dist < TunnelingThresh || std::abs(dist - TunnelingThresh) < 0.0001)
            {
                //Particles are in contact. Add entry to the current matrix equal to VIN/Rc,
                //at index (i,i)
                ValuesG = 1.0/Rc;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
            //Particle-terminal are conducting via tunneling
            else
            {
                //Calculate the tunneling area between particle-terminal via functino call
                long double At = FindTunnelingArea(Indices[i],-1);
                
                //Calcaute the tunneling resistance between particle-termina via function call
                TunnelingResistance = CalcTunnelingResistance(dist, TunnelingThresh, d, At);
                
                //If tunneling resistance is less than Rc, set the resistance between the pair to
                //be equivalent to a contact resistance. This is effectively a piecewise fit.
                if (TunnelingResistance < Rc)
                {
                    TunnelingResistance = Rc;
                }
                
                //Add to the triplet list. For index (i,i), add the inverse
                //of the tunneling resistance
                ValuesG = 1.0/TunnelingResistance;
                G.push_back(Eigen::Triplet<double>(i,i,ValuesG));
            }
        }
    }
    //Return the temporary triplet list
    return G;
}

double RVEdata::CalcTunnelingThreshold(long int i, long int j)
{
    //This function is used to determine the distance the particles would have to be seperated
    //for tunneling conductivity to dominate. For the monodisperse case, this function simply
    //returns the particle diameter defined by the user at simulation start.
    
    //Define particle i and particle j types (from the CBMaterial data objects)
    int iType, jType;
    iType = particle_data[i].GetType();
    jType = particle_data[j].GetType();

    //If iType and jType are < NumCB Fillers, they are both classified as CB particles
    if (iType < NumCBFillers && jType < NumCBFillers)
    {
        //Use the diameters of the particles to define the tunneling threshold.
        int dpi, dpj;
        dpi = CB_particles[particle_data[i].GetTypeID()].GetDiameter()*mult;
        dpj = CB_particles[particle_data[j].GetTypeID()].GetDiameter()*mult;
        return ((dpi+dpj)/2.0);
    }
    //Other scenarios that have not yet been coded as options but the bones are there.
    else if (iType > NumCBFillers && jType > NumCBFillers)
    {
        //Both i and j are CNT particles
        return 0;
    }
    else if (iType > NumCBFillers && jType < NumCBFillers)
    {
        //i is a cnt and j is a cb
        return 0;
    }
    else if (iType < NumCBFillers && jType > NumCBFillers)
    {
        //j is a cnt and i is a cb
        return 0;
    }
    else
    {
        return 0;
    }
}

double RVEdata::CalcTunnelingThresholdToTerminal(long int i)
{
    
    //If Type < NumCB Fillers, the particle is classified as a CB particle
    if (particle_data[i].GetType() < NumCBFillers)
    {
        //return the diameter of the particle in units of nanometers
        return mult*(CB_particles[particle_data[i].GetTypeID()].GetDiameter()/2.0);
    }
    else
    {
        return 0;
    }
}

double RVEdata::CalcTunnelingResistance(double dist, double TunnelingThresh, double u, long double At)
{
    //This function returns the tunneling resistance between conductors separated by a thin
    //insulating barrier of thickness d
    
    //Tunneling Conductivity Parameter definition
    long double h = 6.626*pow(10,-34);           //Planck's constant (m^2kg/s)
    long double e = 1.602176634*pow(10,-19);     //Elementary charge in units of Coulombs
    long double tau = 0.5*1.60218*pow(10,-19);   //Average barrier height of Epoxy
    long double Em = 9.10938356*pow(10,-31);     //electron mass
    double d;                                   //tunneling distance
    
    //Define the tunneling distance in units of meters
    d = (dist - TunnelingThresh)*u/mult;
    
    //Check to see if distance is negative which means something is wrong
    if (d < 0)
    {
        std::cout << "Can't have negative tunneling distance.." << std::endl;
        exit(1);
    }
    
    //Define the temporary high precision floats to serve as numerator and denominator
    long double RtunnNumerator = exp(4.0*M_PI*d*sqrt(2.0 * Em*tau) / h)*(h*h*d);
    long double RtunnDenom = (At*e*e*sqrt(2.0 * Em*tau));
    
    //Calculate the tunneling resistance from the numerator and denominator
    double TR = RtunnNumerator/RtunnDenom;
    
    //Check to make sure the tunneling threshold and dist variables aren't unrealistic. Output
    //strings if an unexpected case arises.
    if (dist - TunnelingThresh > Td)
    {
        std::cout << "Why? How? Dist = " << dist << " TT = " << TunnelingThresh << std::endl;
    }
    
    //Check to make sure tunneling resistance isn't <= 0, which would signify the code is broken.
    if (TR == 0)
    {
        std::cout << "Tunn R can't be 0: Rnumerator = " << RtunnNumerator << " dist= " << dist << " thresh= " << TunnelingThresh << " d= " << d << " u = " << u << " 2.0*EM*tau= " << 2.0*Em*tau << std::endl;
    }
    else if (TR < 0)
    {
        std::cout << "Tunn R can't be less than 0: Rnumer = " << RtunnNumerator << " Rdenom= " << RtunnDenom << std::endl;
    }
    
    //Check to make sure tunneling area isn't = 0, which would signify the code is broken.
    if (At == 0)
    {
        std::cout << " At: " << At;
    }
    
    //Return the tunneling resistance between the pair of conductors
    return TR;
}


double  RVEdata::FindDistanceToTerminal(bool terminal, long int i)
{
    //This function calculates the distance between particle i and the terminal determined
    //by the function argument bool terminal. If terminal == false, check the positive
    //terminal. If terminal == true, check the ground terminal.
    
    //If type < NumCBFillers, it is a CB particle
    if (particle_data[i].GetType() < NumCBFillers)
    {
        if (terminal == false)
        {
            //Return distance from particle i to the positive terminal in nanometers
            return mult*CB_particles[particle_data[i].GetTypeID()].GetXCoordinate();
        }
        else
        {
            //Return distance from particle i to the ground terminal in nanometers
            return mult*(Xbound - CB_particles[particle_data[i].GetTypeID()].GetXCoordinate());
        }
    }
    //This shouldn't happen, but left for error throws anyway
    else
    {
        return 0;
    }
}

long double RVEdata::FindTunnelingArea(long int i, long int j)
{
    //This function returns the cross-sectional area of tunneling between particle pairs.
    //For the monodisperse case, the function simply returns the maximum cross-sectional are
    //of a sphere of diameter = dp. In the case of polydispersity, the tunneling area could
    //be changed to a product of the diameters or some other function.
    
    //If j < 0, particle to terminal tunneling is the case.
    if (j < 0)
    {
        //If type < NumCBFillers, it is a CB particle
        if (particle_data[i].GetType() <= NumCBFillers)
        {
            //Return the max cross sectional area of the particle of diameter dp in m^2
            double dp = mult*CB_particles[particle_data[i].GetTypeID()].GetDiameter()*pow(10,-9);
            return M_PI*pow(dp/2.0,2); //cross sectional area of tunneling path (m^2)
        }
        else
        {
            //CNT particle to terminal, this hasn't been coded yet
            return 0;
        }
    }
    //If j > 0, particle to particle tunneling is the case, and the area depends on the diameters
    //of the particles i and j
    if (j >= 0)
    {
        //If both Types < NumCBFillers, both are CB particles
        if (particle_data[i].GetType() <= NumCBFillers && particle_data[j].GetType() <= NumCBFillers)
        {
            //Return the average of the maximum cross sectional area of the pair in m^2
            double dpi = mult*CB_particles[particle_data[i].GetTypeID()].GetDiameter()*pow(10,-9);
            double dpj = mult*CB_particles[particle_data[j].GetTypeID()].GetDiameter()*pow(10,-9);
            return M_PI*pow((dpi+dpj)/4.0,2); //cross sectional area of tunneling path (m^2)
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
}

bool RVEdata::CheckPosNeg(long int i, bool j)
{
    //This function is used to determine if a particle is connected to either the positve
    //or ground electrode faces. If bool j == true, we check connectivity to ground if
    //bool j == false, we check connectivity to positiver terminal
    
    //Get particle type via object function call
    int Type = particle_data[i].GetType();
    
    //Check to Negative terminal
    if (j == true)
    {
        //If the particle type is < NumCBFillers, it is a CB particle
        if (Type < NumCBFillers)
        {
            //Return negative connectivity status from object function call
            return CB_particles[particle_data[i].GetTypeID()].IsNegative();
        }
        else
        {
            //Not CB particle, we shouldn't arrive here for monodisperse case.
            return 0;
        }
    }
    
    //Check to Positive terminal
    if (j == false)
    {
        //If the particle type is < NumCBFillers, it is a CB particle
        if (Type < NumCBFillers)
        {
            //Return positive connectivity status from object function call
            return CB_particles[particle_data[i].GetTypeID()].IsPositive();
        }
        else
        {
            //Not CB particle, we shouldn't arrive here for monodisperse case.
            return 0;
        }
    }
    //This final case shouldn't happen, but it is here for error throwing
    else
    {
        return 0;
    }
}

void RVEdata::CheckNeighbors()
{
    std::string dir = getcwd(NULL, 0);
    std::ofstream MFErr;
    MFErr.open(dir + "/CheckNeigh.csv");
    long int NumNeighbors = 0;
    for (long int i = 0; i < particle_data.size(); i++)
    {
        std::vector<long int> neigh = CB_particles[i].GetNeighborsVector();
        MFErr << "i: " << i << "," << CB_particles[i].GetXCoordinate() << "," << CB_particles[i].GetYCoordinate() << "," << CB_particles[i].GetZCoordinate() << ",";
        for (int j = 0; j < neigh.size(); j++)
        {
            MFErr << neigh[j] << ",";
            NumNeighbors += 1;
        }
        MFErr << std::endl;
    }
    MFErr.close();
    std::cout << "NumNeighors = " << NumNeighbors << std::endl;
    
    std::ofstream XYZ;
    XYZ.open(dir + "/check_xyz.csv");
    XYZ << Total_Num_Particles << "," << Xbound*mult << "," << Ybound*mult << "," << Zbound*mult << "," << 5 << "," << 1 << "," << 1000 << std::endl;
    
    for (int i = 0; i < Total_Num_Particles; i++)
    {
        XYZ << CB_particles[i].GetXCoordinate()*mult << "," << CB_particles[i].GetYCoordinate()*mult << "," << CB_particles[i].GetZCoordinate()*mult << std::endl;
    }
    XYZ.close();
}

void RVEdata::Output_Ovito_File(std::ofstream &fplot, std::string uid, std::string bashid, std::ofstream &cond_out)
{
    //This function outputs a tab delimited csv file that is used to render the RVE in 3D. The output file
    //is named using the executable process id (bashid), machine id (uid), and specific simulation parameters
    //so that each file name is unique, and no other active executable on the same or another machine can
    //attempt to save using the same name. The files are saved in a directory titled "RVE_Data" will be
    //generated (if it doesn't already exist) in the folder where the executable is being run.
    
    //Define the directories where the saving will occur.
    std::string current_dir = getcwd(NULL,0);
    std::string directory("/RVE_Data/" + std::to_string(Xbound*mult) + "_" + std::to_string(Wcb));
    std::string cond_directory("/Output/" + std::to_string(Xbound*mult) + "_" + std::to_string(Wcb));
    std::string New_Directory(current_dir + directory);
    std::string New_Cond_Directory(current_dir + cond_directory);

    //Check to see if the output directories exist. If they don't, then create them.
    if (boost::filesystem::exists(New_Directory) == false)
    {
        boost::filesystem::create_directory(New_Directory);
    }
    if (boost::filesystem::exists(New_Cond_Directory) == false)
    {
        boost::filesystem::create_directory(New_Cond_Directory);
    }
    
    //Define variables to signal when a unique filename has been found. In instances where previous
    //simulations have been ran with the same parameters as this one, the files will have an integer
    //tag at that end. This iteger signifies that the file is one of many  with the same  parameters.
    bool opened_file = false;
    int file_num = 0;
    
    //Loop until a unique file name has been found.
    while (opened_file == false)
    {
        //Check to see if the filename+file_num exists in the directory. If so increment file_num and
        //try again.
        if (boost::filesystem::exists(New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(Pct_Fill) + "_" + std::to_string(file_num) + ".xyz") == true)
        {
            //Increment file number and try to save again
            file_num += 1;
        }
        else
        {
            //If arrived here, the filename is unique and the files can be saved under that name. To
            //ensure that no funny business happens, the file is quickly created by opening and closing
            //the file immediately. This secures the filename in the system.
            fplot.open(New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(Pct_Fill) + "_" + std::to_string(file_num) + ".xyz");
            cond_out.open(New_Cond_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(Pct_Fill) + "_" + std::to_string(file_num) + ".csv");
            
            //Turn flag to true to exit while loop
            opened_file = true;
        }
        //This is an attempt counter. If this is triggered, something is very likely broken.
        if (file_num > 100)
        {
            std::cout << "File Inc: " << file_num << "\r" << std::flush;
        }
    }
    //Close the new files immediately to reserve the filename in the system
    cond_out.close();
    fplot.close();
    
    //Reopen the coordiante file to populate it
    fplot.open(New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(Pct_Fill) + "_" + std::to_string(file_num) + ".xyz");
    
    //The first row of the OVITO file needs the total numbner of particles contained in the file
    fplot << Total_Num_Particles << std::endl << "X Y Z Diameter ColorScale" << std::endl;
    
    //Loop through all the particles and input their coordinates/diameter (seperated by spaces) to the file
    for (long int i = 0; i < Total_Num_Particles; i++)
    {
        fplot << GetCBParticle(i)->GetXCoordinate()*mult << " " << GetCBParticle(i)->GetYCoordinate()*mult << " " << GetCBParticle(i)->GetZCoordinate()*mult << " " << GetCBParticle(i)->GetDiameter()*mult/2 << std::endl;
    }
    //Close the file
    fplot.close();
    
    //Open the conducitity report file to output the results of the conductivity analysis
    cond_out.open(New_Cond_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(Pct_Fill) + "_" + std::to_string(file_num) + ".csv");
    cond_out << 0 << "," << RVEresistance << "," << RVEconductivity << "," << std::endl;

    
    /*
    while (opened_file == false)
    {
        if (boost::filesystem::exists(New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(file_num) + ".vtk") == true)
        {
            //Increment file number and try to save again
            file_num += 1;
        }
        else
        {
            fplot.open(New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(file_num) + ".vtk");
            opened_file = true;
        }
        if (file_num > 100)
        {
            std::cout << "File Inc: " << file_num << "\r" << std::flush;
        }
    }
    fplot.close();
    std::cout << "While done" << std::endl;
    float* new_arr = new float[Total_Num_Particles*3]();
    int* vardim = new int[2]();
    vardim[0] = 1;
    vardim[1] = 1;
    float **vars;
    vars = new float*[2];
    for (int i = 0; i < 2; i++)
    {
        vars[i] = new float[Total_Num_Particles];
    }
    const char *varnames[] = {"id", "diameter"};
    
    std::vector<int> p_coords(Total_Num_Particles*3);
    for (long int i = 0; i < Total_Num_Particles; i++)
    {
        new_arr[i*3] = GetCBParticle(i)->GetXCoordinate()*mult;
        new_arr[i*3 + 1] = GetCBParticle(i)->GetYCoordinate()*mult;
        new_arr[i*3 + 2] = GetCBParticle(i)->GetZCoordinate()*mult;
        vars[0][i] = 1;
        vars[1][i] = GetCBParticle(i)->GetDiameter()*mult;
        //fplot << GetCBParticle(i)->GetXCoordinate() << " " << GetCBParticle(i)->GetYCoordinate() << " " << GetCBParticle(i)->GetZCoordinate() << " 1 " << GetCBParticle(i)->GetDiameter()/2. << std::endl;
    }
    std::string vtk_name = New_Directory + "/" + bashid + uid + "_" + std::to_string(Zbound*mult) + "_" + std::to_string(Pct_Rand*1000) + "_" + std::to_string(file_num) + ".vtk";
    write_point_mesh(vtk_name.c_str(), 1, Total_Num_Particles, new_arr, 2, vardim, varnames, vars);*/
}

